[{"content":"Циклы for и while, операторы break и continue, волшебное слово else Я расскажу о циклах for и while, операторах break и continue, а также о слове else, которое, будучи употребленное с циклом, может сделать программный код несколько более понятным.\nЦикл while While - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; i = 5 \u0026gt;\u0026gt;\u0026gt; while i \u0026lt; 15: ... print(i) ... i = i + 2 ... 5 7 9 11 13 Цикл for Общее понятие Цикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (например строке или списку), и во время каждого прохода выполняет тело цикла. Цикл for используется в том случае, когда необходимо выполнить некоторую часть кода до тех пор, пока не будет выполнено заданное условие. Цикл for также называют циклом c предусловием. Лучше использовать цикл for, если количество итераций известно заранее.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheelllloo wwoorrlldd range() Мы используем встроенную функцию Python range. Функция range создаст список длинной в «n» элементов. В Python версии 2.Х существует другая функция под названием xrange, которая является генератором чисел и не такая ресурсоемкая, как range. Ранее разработчики сменили xrange на range в Python 3. Вот пример:\n1 print(range(5)) # ответ: range(0, 5) Как вы видите, функция range взяла целое число и вернула объект range. Функция range также принимает начальное значение, конечное значение и значение шага. Вот еще два примера:\n1 2 3 4 5 a = range(5, 10) print(a) # range(5, 10) b = list(range(1, 10, 2)) print(b) # [1, 3, 5, 7, 9] В пером примере показано, что вы можете передать начальное и конечное значение, и функция range вернет числа, начиная с начального значения вплоть до (но не включая) последнее значение. Например, при запросе 5-10 мы получим 5-9. Во втором примере видно, как использовать функцию списка (list) для того, чтобы функция range вернула каждый второй элемент, между 1 и 10. Так что она начинает с 1, пропускает 2 и так далее. Теперь вы, наверное, гадаете, что же именно она будет делать с циклами? Что-ж, есть один простой способ показать, как работает цикл с использованием функции range! Давайте взглянем:\n1 2 for number in range(5): print(number) Что здесь произошло? Давайте почитаем слева на право, чтобы понять это. Для каждого числа в диапазоне 5 мы вводим число. Мы знаем, что если мы вызываем range со значением 5, мы получим список из 5 элементов. Так что каждый раз, проходя через цикл, она выводит каждый из элементов. Цикл for, показанный выше, может быть эквивалентом следующего:\n1 2 for number in [0, 1, 2, 3, 4]: print(number) Мы попробуем применить цикл в функции range, но нам нужно вывести только целые числа. Чтобы сделать это, нам нужно использовать условный оператор вместо параметра шага range. Это можно сделать следующим образом:\n1 2 3 4 5 6 7 8 for number in range(10): if number % 2 == 0: print(number) # 0 # 2 # 4 # 6 # 8 Вы наверное гадаете, что вообще здесь происходит? Что еще за знак процента? В Python, % называется оператором модуля. Когда вы используете оператор модуля, он возвращает остаток. Когда вы делите целое число на два, вы получаете число без остатка, так что мы выводим эти числа. Вам, возможно, не захочется использовать оператор модуля часто в будущем, но в моей работе он нередко помогает. Теперь мы можем взглянуть на цикл while.\nСловари Функция range лишь делает результат несколько меньшим. Цикл for может обходить любой итератор Python. Мы уже видели, как именно он может работать со списком. Давайте взглянем, может ли он выполнять итерацию со словарем.\n1 2 3 4 a_dict = {\u0026#34;one\u0026#34;:1, \u0026#34;two\u0026#34;:2, \u0026#34;three\u0026#34;:3} for key in a_dict: print(key) Когда вы используете for в словаре, вы увидите, что он автоматически перебирает ключи. Вам не нужно указывать ключ for в a_dict.keys() (впрочем, это также работает). Python делает только нужные нам вещи. Вы возможно думаете, почему ключи выводятся в другом порядке, отличном от того, какой был указан в словаре? Как мы знаем из соответствующей статьи, словари не упорядочены, так что мы можем выполнять итерацию над ними, при этом ключи могут быть в любом порядке. Теперь, зная, что ключи могут быть отсортированы, вы можете отсортировать их до итерации. Давайте немного изменим словарь, чтобы увидеть, как это работает.\n1 2 3 4 5 6 7 8 9 a_dict = {1:\u0026#34;one\u0026#34;, 2:\u0026#34;two\u0026#34;, 3:\u0026#34;three\u0026#34;} keys = a_dict.keys() keys = sorted(keys) for key in keys: print(key) # 1 # 2 # 3 Давайте остановимся и разберемся с тем, что делает этот код. Во-первых, мы создали словарь, в котором ключи выступают в качестве целых чисел, вместо строк. Далее, мы извлекли ключи из словаря. Каждый раз, когда вы взываете метод keys(), он возвращает неупорядоченный список ключей. Если вы выведите их, и увидите, что они расположен в порядке по возрастанию, то это просто случайность. Теперь у нас есть доступ к ключам словаря, которые хранятся в переменной, под названием keys. Мы сортируем наш список, после чего используем цикл for в нем. Теперь мы готовы к тому, чтобы сделать все немного интереснее.\nОператор continue Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;o\u0026#39;: ... continue ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheellll wwrrlldd Оператор break Оператор break досрочно прерывает цикл.\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;o\u0026#39;: ... break ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheellll Волшебное слово else Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же \u0026ldquo;естественным\u0026rdquo; образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;a\u0026#39;: ... break ... else: ... print(\u0026#39;Буквы a в строке нет\u0026#39;) ... Буквы a в строке нет ","date":"2022-07-23T04:00:00Z","permalink":"https://kotaz.github.io/p/py05/","title":"Циклы Python"},{"content":"Инструкция if Условная инструкция if-elif-else (её ещё иногда называют оператором ветвления) - основной инструмент выбора в Python. Проще говоря, она выбирает, какое действие следует выполнить, в зависимости от значения переменных в момент проверки условия.\nСинтаксис Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:\n1 2 3 4 5 6 if test1: state1 elif test2: state2 else: state3 Простой пример (напечатает \u0026rsquo;true\u0026rsquo;, так как 1 - истина):\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; if 1: ... print(\u0026#39;true\u0026#39;) ... else: ... print(\u0026#39;false\u0026#39;) ... true Чуть более сложный пример (его результат будет зависеть от того, что ввёл пользователь):\n1 2 3 4 5 6 7 a = int(input()) if a \u0026lt; -5: print(\u0026#39;Low\u0026#39;) elif -5 \u0026lt;= a \u0026lt;= 5: print(\u0026#39;Mid\u0026#39;) else: print(\u0026#39;High\u0026#39;) Проверка истинности в Python Любое число, не равное 0, или непустой объект - истина. Числа, равные 0, пустые объекты и значение None - ложь Операции сравнения применяются к структурам данных рекурсивно Операции сравнения возвращают True или False Логические операторы and и or возвращают истинный или ложный объект-операнд Логические операторы X and Y: Истина, если оба значения X и Y истинны. X or Y: Истина, если хотя бы одно из значений X или Y истинно. not X: Истина, если X ложно. X is Y: Истина, если объект X является объектом Y. X is not Y: Истина, если объект X не является объектом Y. X == Y: Истина, если значения X и Y равны. X != Y: Истина, если значения X и Y не равны. X \u0026gt; Y: Истина, если значение X больше значения Y. X \u0026gt;= Y: Истина, если значение X больше или равно значению Y. X \u0026lt; Y: Истина, если значение X меньше значения Y. X \u0026lt;= Y: Истина, если значение X меньше или равно значению Y. Трехместное выражение if/else Следующая инструкция:\n1 2 3 4 if X: A = Y else: A = Z довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение if/else:\n1 A = Y if X else Z В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; A = \u0026#39;t\u0026#39; if \u0026#39;spam\u0026#39; else \u0026#39;f\u0026#39; \u0026gt;\u0026gt;\u0026gt; A \u0026#39;t\u0026#39; ","date":"2022-07-23T03:00:00Z","permalink":"https://kotaz.github.io/p/py04/","title":"Инструкция if"},{"content":"Почему моя программа не работает? (FAQ) Не работает функция input. Пишет SyntaxError Пример кода:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a = input() hello world File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1 hello world ^ SyntaxError: unexpected EOF while parsing Причина: Вы запустили Python 2.\nРешение: Установить Python 3.\nГде-то увидел простую программу, а она не работает Пример кода:\n1 2 3 4 5 6 7 8 name = raw_input() print name Ошибка: File \u0026#34;a.py\u0026#34;, line 3 print name ^ SyntaxError: invalid syntax Причина: Вам подсунули программу на Python 2.\nРешение: Прочитать об отличиях Python 2 от Python 3. Переписать её на Python 3. Например, данная программа на Python 3 будет выглядеть так:\n1 2 name = input() print(name) TypeError: Can't convert 'int' object to str implicitly Пример кода:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a = input() + 5 8 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: Can\u0026#39;t convert \u0026#39;int\u0026#39; object to str implicitly Причина: Нельзя складывать строку с числом.\nРешение: Привести строку к числу с помощью функции int(). Кстати, заметьте, что функция input() всегда возвращает строку!\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = int(input()) + 5 8 \u0026gt;\u0026gt;\u0026gt; a 13 SyntaxError: invalid syntax Пример кода:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; if a == 5 ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 3 if a == 5 ^ SyntaxError: invalid syntax Причина: Забыто двоеточие.\nРешение:\n1 2 3 a = 5 if a == 5: print(\u0026#39;Ура!\u0026#39;) SyntaxError: invalid syntax 2 Пример кода:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; if a = 5: ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 3 if a = 5 ^ SyntaxError: invalid syntax Причина: Забыто равно.\nРешение:\n1 2 3 a = 5 if a == 5: print(\u0026#39;Ура!\u0026#39;) NameError: name 'a' is not defined Пример кода:\n1 print(a) Причина: Переменная \u0026ldquo;a\u0026rdquo; не существует. Возможно, вы опечатались в названии или забыли инициализировать её.\nРешение: Исправить опечатку.\n1 2 a = 10 print(a) IndentationError: expected an indented block Пример кода:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; 0: ... print(a) Причина: Нужен отступ.\nРешение:\n1 2 3 a = 10 if a \u0026gt; 0: print(a) TabError: inconsistent use of tabs and spaces in indentation Пример кода:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; 0: ... print(a) ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 5 print(\u0026#39;Ура!\u0026#39;) ^ TabError: inconsistent use of tabs and spaces in indentation Причина: Смешение пробелов и табуляции в отступах.\nРешение: Исправить отступы.\n1 2 3 4 a = 10 if a \u0026gt; 0: print(a) print(\u0026#39;Ура!\u0026#39;) UnboundLocalError: local variable 'a' referenced before assignment Пример кода:\n1 2 3 4 5 6 def f(): a += 1 print(a) a = 10 f() 1 2 3 4 5 6 Traceback (most recent call last): File \u0026#34;a.py\u0026#34;, line 7, in \u0026lt;module\u0026gt; f() File \u0026#34;a.py\u0026#34;, line 3, in f a += 1 UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment Причина: Попытка обратиться к локальной переменной, которая ещё не создана.\nРешение:\n1 2 3 4 5 6 7 def f(): global a a += 1 print(a) a = 10 f() Программа выполнилась, но в файл ничего не записалось / записалось не всё Пример кода:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;bla\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; Причина: Не закрыт файл, часть данных могла остаться в буфере.\nРешение:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;bla\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; f.close() \u0026gt;\u0026gt;\u0026gt; ","date":"2022-07-23T02:00:00Z","permalink":"https://kotaz.github.io/p/py03/","title":"Почему моя программа не работает? (FAQ)"},{"content":"Начало работы с языком Сейчас большинство операций с кодом будет проводиться внутри файла. Если вы хотите повторить то, что происходит тут, создайте файл и пишите код туда. О том, как запустить файл, можно узнать в прошлом уроке.\nВывод Вывод на экран Выводимые данные можно перечислять через запятую\n1 2 3 4 5 print(\u0026#34;Hello, world!\u0026#34;) # Hello, world! print(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;) # A B print(1, 2, 3) # 1 2 3 print(True, False, None) # True False None print(\u0026#34;a\u0026#34;, 1, True) # a 1 True Так же можно проводить простые вычисления\n1 2 3 print(1 + 2) # 3 print(1 + 2, 3 + 4) # 3 7 print(1 - 3) # -2 sep = sep — это может быть строка, которую необходимо вставлять между значениями, по умолчанию — пробел.\nВставим список слов в print и разделим их с помощью символа новой строки. Еще раз: по умолчанию разделитель добавляет пробел между каждым словом.\n1 2 print(\u0026#39;туториал\u0026#39;, \u0026#39;по\u0026#39;, \u0026#39;функции\u0026#39;, \u0026#39;print()\u0026#39;) # туториал по функции print() \\n перенесет каждое слово на новую строку\n1 2 3 4 5 print(\u0026#39;туториал\u0026#39;, \u0026#39;по\u0026#39;, \u0026#39;функции\u0026#39;, \u0026#39;print()\u0026#39;, sep=\u0026#39;\\n\u0026#39;) # туториал # по # функции # print() end = end — это строка, которая добавляется после последнего значения. По умолчанию — это перенос на новую строку (\\n). С помощью аргумента end программист может самостоятельно определить окончание выражения print.\nПредположим, есть две строки, а задача состоит в том, чтобы объединить их, оставив пробел. Для этого нужно в первой функции print указать первую строку, str1 и аргумент end с кавычками. В таком случае на экран выведутся две строки с пробелом между ними.\n1 2 3 4 5 6 7 8 9 10 str1 = \u0026#39;туториал по\u0026#39; str2 = \u0026#39;функции print()\u0026#39; print(str1) print(str2) # туториал по # функции print() print(str1, end=\u0026#39; \u0026#39;) print(str2) # туториал по функции print() Возьмем другой пример, где есть функция, которая должна выводить значения списка на одной строке. Этого можно добиться с помощью такого значения аргумента end:\n1 2 3 4 5 6 7 def value(items): for item in items: print(item, end=\u0026#39; \u0026#39;) value([1,2,3,4]) # 1 2 3 4 Переменные Переменные содержат данные. Благодаря этому к ним можно обращаться, заново использовать, вызывать, назначать и так далее. Понимать переменные важно для работы с любой логикой в программировании. Это то, что знает любой программист вне зависимости от языка программирования, и поэтому это так важно для начинающих. Простейшее определение переменной — это именованный контейнер для данных, к которым нужно обращаться в программе. Есть 2 основные причины для этого:\nЗачастую данные — это больше чем 2 символа. Обычно к ним нужно обращаться по несколько раз. Где используется? Сложно представить программирование без переменных. Это как обращаться к людям, не используя их имена и фамилии. Можно только представить, насколько это было бы неудобно. В программировании переменные используются для определения и обращения к данным разных размеров, типов и форм. Правила использования При присвоении значения переменная всегда находится слева, а данные — справа. Имя переменной может начинаться с символа или нижнего подчеркивания (_), но не с числа. Для вывода значения переменной с помощью функции print нужно передавать ее без кавычек. Переменные создаются по принципу: \u0026lt;имя\u0026gt; = \u0026lt;значение\u0026gt;. Не смотря на поддержку русских названий переменных, рекомендуется использовать латинские названия. Есть негласные правила для названий. Для переменных, объектов, функций, иногда констант это snake_case (маленькми буквами, слова отделяются нижним подчеркиванием), а для классов - CamelCase (большими буквами, первая буква большая). Для констант применяется так же UPPER_CASE (большими буквами, через нижнее подчеркивание). Так же рекомендуется избегать транслита. Лучше назвать переменную variable, а не peremennaya. Частые ошибки Начинать имя переменной с цифры. Использовать символы (кроме нижнего подчеркивания) в имени переменной. Использовать в переменной пробелы. Примеры использования переменных Предположим, что есть большое число: 149597970. Оно обозначает расстояние между Солнцем и Землей в километрах. Предположим, что к этому значению нужно обратиться для выполнения вычислений. Вместо того, чтобы каждый раз вводить его, можно просто использовать переменную. Вот так:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; sun_to_earth = 149597970 \u0026gt;\u0026gt;\u0026gt; sun_to_earth = sun_to_earth + 1 \u0026gt;\u0026gt;\u0026gt; print(sun_to_earth) 149597971 Разберем код примера: Сначала создается переменная sun_to_earth, и ей присваивается значение 149597970. Переменной sun_to_earth присваивается новое значение — 149597971.\nПеременные - это место в памяти, куда можно сохранить данные.\n1 2 3 4 5 a = 1 + 2 # 3 b = \u0026#34;123\u0026#34; c = True d = None print(a, b, c, d) # 1 123 True None Парочка интересных моментов языка\nПри выводе на экран значение переменной никуда не девается и мы можем вывести значение сколько раз угодно print все еще может выводить значения одновременно с переменным В отличии от многих других языков в python отсутствует типизация и ему абсолютно параллельно, что мы будем присваивать переменной - новое число или новую строку. Делать мы можем это сколько раз угодно. При новом присваивании питон автоматически меняет тип переменной Мы можем указывать эту переменную в вычислениях, про операции с переменными и константами мы поговорим отдельно Мы можем резко поменять то, что хранится в переменной - было число, стало строка Ввод 1 2 name = input(\u0026#34;Введите ваше имя: \u0026#34;) # Вводим имя print(\u0026#34;Привет, \u0026#34;, name) # Выводим приветствие input - это функция, которая требует 1 аргумент, это строка, которая будет выведена перед вводом. Возвращает введенную строку. print - к слову, тоже функция, но на вход принимает любое количество аргументов, которые будут распечатаны. Возвращает None.\nТипы данных Основных типо данных несколько. Сейчас говорится не о всех\nТип Описание Пример int Целое число 123 float Число с плавающей точкой 1.23 str Строка \u0026ldquo;Hello, world!\u0026rdquo; bool Логическое значение True, False complex Комплексное число 1 + 2j none Значение не определено None list Список [1, 2, 3] set Множество {1, 2, 3} tuple Кортеж (1, 2, 3) dict Словарь {1: \u0026ldquo;one\u0026rdquo;, 2: \u0026ldquo;two\u0026rdquo;} Строки Про кавычки \u0026quot;1\u0026quot; и '1' - эти 2 записи - одно и тоже \u0026quot;строка в \u0026quot;кавычках\u0026quot;\u0026quot; - такая запись вызовет ошибки, изза того, что питон запутается в одинаковых кавычках 'тут \u0026quot;кавычки\u0026quot;' - тут питон не запутался в кавычках, так как они разные \u0026quot;тут 'кавычки'\u0026quot; - кавычки можно комбинировать, все четыре типа кавычек (', \u0026quot;, \u0026quot;\u0026quot;\u0026quot;, ''') можно комбинировать, главное, что бы строка начиналась и заканчивалась одним типом кавычек 'текст \\'в\\' кавычках' - тут с помощью \\ кавычки были экранизированы, и теперь питон не запутается \u0026quot; 123 \\\u0026quot; 123\u0026quot; - тот же самый случай с другими кавычками\nПро \\ \\ внутри строки отвечает за вывод некоторых символов и экранизацию, пока что просто помните, что: \\\u0026quot; \\' - \u0026ldquo;защищеные\u0026rdquo; от поломки кода кавычки, которые можно использовать в тексте \\\\ - вывод \\ без каких либо экранизаций и прочего \\n \\t - новая строка и табуляция (как при нажатии на Tab)\nПро мультистроки Иногда бывает очень много текста, который содержит переносы строк (\\n), тогда можно использовать мультистроки, который можно растягивать на любое количество строк кода, в то время как обычные - нельзя:\n1 2 3 4 5 6 7 8 9 10 11 print(\u0026#34;\u0026#34;\u0026#34; Этот текст содержит множество переносов строк и огромное количество текста... \u0026#34;\u0026#34;\u0026#34;) # Убрать первый перенос строки print(\u0026#34;\u0026#34;\u0026#34;\\ 123 123 \u0026#34;\u0026#34;\u0026#34;) ''' и \u0026quot;\u0026quot;\u0026quot; - опять же одно и тоже Экранизировать ' внутри ''' или \u0026quot; внутри \u0026quot;\u0026quot;\u0026quot; - не надо, питон запутается лишь если вы напечатаете сразу 3 кавычки подряд внутри мультстроки Если вы сразу после первой тройной кавычки ставите перенос строки - то при выводе на экран у вас выведется одна пустая строка. Что бы этого избежать - поставьте \\ который уберет эту лишнюю пустую строку. Так же можно писать любой текст сразу после тройных кавычек вместо \\ Целые числа (int), комплексные (complex) и вещественные числа (float) Целые числа (int) Числа в Python 3 ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:\nОперация Описание x + y Сложение x - y Вычитание x * y Умножение x / y Деление x // y Получение целой части от деления x % y Остаток от деления -x Смена знака числа abs(x) Модуль числа divmod(x, y) Пара (x // y, x % y) x ** y Возведение в степень pow(x, y[, z]) xy по модулю (если модуль задан) Длинная арфиметика Также нужно отметить, что целые числа в python 3, в отличие от многих других языков, поддерживают длинную арифметику (однако, это требует больше памяти).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026gt;\u0026gt;\u0026gt; 255 + 34 289 \u0026gt;\u0026gt;\u0026gt; 5 * 2 10 \u0026gt;\u0026gt;\u0026gt; 20 / 3 6.666666666666667 \u0026gt;\u0026gt;\u0026gt; 20 // 3 6 \u0026gt;\u0026gt;\u0026gt; 20 % 3 2 \u0026gt;\u0026gt;\u0026gt; 3 ** 4 81 \u0026gt;\u0026gt;\u0026gt; pow(3, 4) 81 \u0026gt;\u0026gt;\u0026gt; pow(3, 4, 27) 0 \u0026gt;\u0026gt;\u0026gt; 3 ** 150 369988485035126972924700782451696644186473100389722973815184405301748249 Побитовые операции Над целыми числами также можно производить битовые операции\nОперация Описание x | y Побитовое или x ^ y Побитовое исключающее или x \u0026amp; y Побитовое и x \u0026laquo; n Битовый сдвиг влево x \u0026raquo; y Битовый сдвиг вправо ~x Инверсия битов Дополнительные методы int.bit_length() - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и лидирующих нулей.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; n = -37 \u0026gt;\u0026gt;\u0026gt; bin(n) \u0026#39;-0b100101\u0026#39; \u0026gt;\u0026gt;\u0026gt; n.bit_length() 6 int.to_bytes(length, byteorder, *, signed=False) - возвращает строку байтов, представляющих это число.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; (1024).to_bytes(2, byteorder=\u0026#39;big\u0026#39;) b\u0026#39;\\x04\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; (1024).to_bytes(10, byteorder=\u0026#39;big\u0026#39;) b\u0026#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; (-1024).to_bytes(10, byteorder=\u0026#39;big\u0026#39;, signed=True) b\u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; x = 1000 \u0026gt;\u0026gt;\u0026gt; x.to_bytes((x.bit_length() // 8) + 1, byteorder=\u0026#39;little\u0026#39;) b\u0026#39;\\xe8\\x03\u0026#39; classmethod int.from_bytes(bytes, byteorder, *, signed=False) - возвращает число из данной строки байтов. 1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00\\x10\u0026#39;, byteorder=\u0026#39;big\u0026#39;) 16 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00\\x10\u0026#39;, byteorder=\u0026#39;little\u0026#39;) 4096 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\xfc\\x00\u0026#39;, byteorder=\u0026#39;big\u0026#39;, signed=True) -1024 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\xfc\\x00\u0026#39;, byteorder=\u0026#39;big\u0026#39;, signed=False) 64512 \u0026gt;\u0026gt;\u0026gt; int.from_bytes([255, 0, 0], byteorder=\u0026#39;big\u0026#39;) 16711680 Системы счисления Те, у кого в школе была информатика, знают, что числа могут быть представлены не только в десятичной системе счисления. К примеру, в компьютере используется двоичный код, и, к примеру, число 19 в двоичной системе счисления будет выглядеть как 10011. Также иногда нужно переводить числа из одной системы счисления в другую. Python для этого предоставляет несколько функций:\nint([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно. bin(x) - преобразование целого числа в двоичную строку. hex(х) - преобразование целого числа в шестнадцатеричную строку. oct(х) - преобразование целого числа в восьмеричную строку. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt;\u0026gt;\u0026gt; a = int(\u0026#39;19\u0026#39;) # Переводим строку в число \u0026gt;\u0026gt;\u0026gt; b = int(\u0026#39;19.5\u0026#39;) # Строка не является целым числом Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in ValueError: invalid literal for int() with base 10: \u0026#39;19.5\u0026#39; \u0026gt;\u0026gt;\u0026gt; c = int(19.5) # Применённая к числу с плавающей точкой, отсекает дробную часть \u0026gt;\u0026gt;\u0026gt; print(a, c) 19 19 \u0026gt;\u0026gt;\u0026gt; bin(19) \u0026#39;0b10011\u0026#39; \u0026gt;\u0026gt;\u0026gt; oct(19) \u0026#39;0o23\u0026#39; \u0026gt;\u0026gt;\u0026gt; hex(19) \u0026#39;0x13\u0026#39; \u0026gt;\u0026gt;\u0026gt; 0b10011 # Так тоже можно записывать числовые константы 19 \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;10011\u0026#39;, 2) 19 \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0b10011\u0026#39;, 2) 19 Вещественные числа (float) Вещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 0.9999999999999999 Для высокой точности используют другие объекты (например Decimal и Fraction)).\nТакже вещественные числа не поддерживают длинную арифметику:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = 3 ** 1000 \u0026gt;\u0026gt;\u0026gt; a + 0.1 Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in OverflowError: int too large to convert to float Простенькие примеры работы с числами:\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; c = 150 \u0026gt;\u0026gt;\u0026gt; d = 12.9 \u0026gt;\u0026gt;\u0026gt; c + d 162.9 \u0026gt;\u0026gt;\u0026gt; p = abs(d - c) # Модуль числа \u0026gt;\u0026gt;\u0026gt; print(p) 137.1 \u0026gt;\u0026gt;\u0026gt; round(p) # Округление 137 Дополнительные методы\nfloat.as_integer_ratio() - пара целых чисел, чьё отношение равно этому числу.\nfloat.is_integer() - является ли значение целым числом.\nfloat.hex() - переводит float в hex (шестнадцатеричную систему счисления).\nclassmethod float.fromhex(s) - float из шестнадцатеричной строки.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; (10.5).hex() \u0026#39;0x1.5000000000000p+3\u0026#39; \u0026gt;\u0026gt;\u0026gt; float.fromhex(\u0026#39;0x1.5000000000000p+3\u0026#39;) 10.5 Помимо стандартных выражений для работы с числами (а в Python их не так уж и много), в составе Python есть несколько полезных модулей.\nМодуль math предоставляет более сложные математические функции.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi 3.141592653589793 \u0026gt;\u0026gt;\u0026gt; math.sqrt(85) 9.219544457292887 Модуль random реализует генератор случайных чисел и функции случайного выбора.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() 0.15651968855132303 Комплексные числа (complex) В Python встроены также и комплексные числа:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026gt;\u0026gt;\u0026gt; x = complex(1, 2) \u0026gt;\u0026gt;\u0026gt; print(x) (1+2j) \u0026gt;\u0026gt;\u0026gt; y = complex(3, 4) \u0026gt;\u0026gt;\u0026gt; print(y) (3+4j) \u0026gt;\u0026gt;\u0026gt; z = x + y \u0026gt;\u0026gt;\u0026gt; print(x) (1+2j) \u0026gt;\u0026gt;\u0026gt; print(z) (4+6j) \u0026gt;\u0026gt;\u0026gt; z = x * y \u0026gt;\u0026gt;\u0026gt; print(z) (-5+10j) \u0026gt;\u0026gt;\u0026gt; z = x / y \u0026gt;\u0026gt;\u0026gt; print(z) (0.44+0.08j) \u0026gt;\u0026gt;\u0026gt; print(x.conjugate()) # Сопряжённое число (1-2j) \u0026gt;\u0026gt;\u0026gt; print(x.imag) # Мнимая часть 2.0 \u0026gt;\u0026gt;\u0026gt; print(x.real) # Действительная часть 1.0 \u0026gt;\u0026gt;\u0026gt; print(x \u0026gt; y) # Комплексные числа нельзя сравнить Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in TypeError: unorderable types: complex() \u0026gt; complex() \u0026gt;\u0026gt;\u0026gt; print(x == y) # Но можно проверить на равенство False \u0026gt;\u0026gt;\u0026gt; abs(3 + 4j) # Модуль комплексного числа 5.0 \u0026gt;\u0026gt;\u0026gt; pow(3 + 4j, 2) # Возведение в степень (-7+24j) Для работы с комплексными числами используется также модуль cmath.\nЗавершение Статья может быть моментами неточной. Я буду рад почитать ваши комментари :)\n","date":"2022-07-22T01:00:00Z","permalink":"https://kotaz.github.io/p/py02/","title":"Основы Python"},{"content":"Установка Python Установка на Windows Я не буду долго зацикливаться на этом этапе. Скачать установщик можно на python.org. Если качать Python с других сайтов, можно подцепить вирус или троян. Скачивайте программы только с официальных сайтов. После загрузки отметьте Add to path и проследуйте инструкциям. В windows 10 может появиться предупреждение с кнопкой щита (Disable Length Limit ), стоит нажать на нее.\nУстановка на Linux Для каждого дистрибутива есть свой пакетный менеджер, попробуйте найти информацию в интернете\napt install python - ubuntu и другие системы, использующие apt pkg/apt install python - Термукс (если вы собираетесь использовать телефон) pacman -S python - arch linux и другие системы, использующие pacman yum install python - centos и другие системы, использующие yum dnf install python - fedora и другие системы, использующие dnf zypper install python - opensuse и другие системы, использующие zypper В случае ошибок прав используйте sudo в начале команды, что бы запустить процесс установки от имени администратора. В большинстве случаев вас попросят подтвердить операцию - введите Y и нажмите Enter.\nПроверка и интерактивный режим В постах, где используется \u0026raquo;\u0026gt; и \u0026hellip; - используется интерактивный режим. Язык питон интерпретируемый (так же как и javascript, например) - то есть каждое действие в языке сначала читается, потом сразу выполняется. В других (компилируемых) языках (c++, java, etc\u0026hellip;) сначала создается готовый файл, а потом его можно сразу запустить без дополнительных инструментов\nКомпилятор (англ. compiler - составитель, собиратель) читает всю программу целиком, делает ее перевод и создает законченный вариант программы на машинном языке, который затем и выполняется. Результат работы компилятора — бинарный исполняемый файл. Интерпретатор (англ. interpreter - истолкователь, устный переводчик) переводит и выполняет программу строка за строкой.\nКогда установка закончится, нужно проверить, что всё было сделано правильно. Для этого в командной строке наберите py (латиницей) или python и нажмите клавишу ввода. Если всё хорошо, в ответ Python вам напишет номер своей версии и сборки и предложит несколько команд для знакомства с собой: Пожалуй, самый простой способ запускать программы на языке Python - это вводить инструкции непосредственно в командной строке интерпретатора, которая иногда называется интерактивной оболочкой. Например, выведем на экран \u0026ldquo;hello world\u0026rdquo; и рассмотрим парочку примеров:\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, world!\u0026#34;) Hello, world! \u0026gt;\u0026gt;\u0026gt; # Это комментарий, пайтон ничего не делает \u0026gt;\u0026gt;\u0026gt; # Или Попробуем вывести на экран число пять: \u0026gt;\u0026gt;\u0026gt; 5 5 \u0026gt;\u0026gt;\u0026gt; # Посчитаем 2+2*2: \u0026gt;\u0026gt;\u0026gt; 2+2*2 6 Заходя в пперед, есть более сложные операторы, которые требуют ввода на несколько строк, в таком случае, приглашение меняется с \u0026gt;\u0026gt;\u0026gt; на .... Этот режим продолжается до тех пор, пока вы не нажмете Enter, оставив пустую строку:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; if 2+2*2 == 6: ... print(\u0026#34;Верно!\u0026#34;) ... else: ... print(\u0026#34;Неверно!\u0026#34;) ... Верно! Запуск файлов Алгоритм действий прост:\nСоздаем файл любым способом. Файл должен оканчиваться на .py. Например, hello.py. Запускаем терминал/консоль (или запускаем прямо в папке с файлом) Windows: Windows + R - Вводим cmd - Enter Linux Ctrl + Shift + T Передвигаемся к файлу Вариант 1: cd ПОЛНЫЙ_ПУТЬ_К_ФАЙЛУ cd C:\\Users\\Вася\\Desktop\\hello.py - Windows cd /home/user/hello.py - Linux Вариант 2: Постепенно предвижение cd ВЛОЖЕННАЯ_ПАПКА - перейти в папку cd .. - для передвижения на уровень вверх Linux ls / Windows dir - для просмотра содержимого папки Вводим команду для запуска файла Вариант 1: python hello.py - универсальный метод для запуска любого файла на Python Вариант 2: python3 hello.py - указываем, что используем имеено Python 3.x.x Вариант 3: py -3 hello.py - лучший метод для Windows Мои примеры будут приближены к Linux, поэтому мои действия:\n1 2 3 4 5 6 ~$ touch hello.py # Создаем файл ~$ nano hello.py # Открываем файл в редакторе nano, редактируем и сохраняем ~$ cat hello.py # Выводим содержимое файла print(\u0026#34;Hello, world!\u0026#34;) ~$ python hello.py # Запускаем файл Hello, world! Завершение Статья может быть моментами неточной. Я буду рад почитать ваши комментари :)\n","date":"2022-07-22T00:00:00Z","image":"https://kotaz.github.io/p/py01/00_placeholder_hu2c7e018ed9f753eaee0b80b8a0ca4196_10087_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotaz.github.io/p/py01/","title":"Введение в Python"},{"content":"Добро пожаловать Тут будут публиковаться различные гайды и курсы по различным темам\n","date":"2022-07-22T00:00:00Z","permalink":"https://kotaz.github.io/p/first/","title":"Первый пост"}]