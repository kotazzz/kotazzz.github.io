[{"content":"Мы закончили изучать базовые вещи в C++, такие как ввод, вывод, переменные, условия, арифметические и логические операторы, циклы и массивы. Теперь можно решить множество несложных задач имея эти знания. Этот пост содержит в себе набор задач для оттачивания навыка написания програм на С++\nЗадачи Разрезание торта на равные части Помогите Пете разработать алгоритм для быстрого разрезания круглого торта на N равных частей. Учтите, что разрезы могут быть выполнены как по радиусу, так и по диаметру.\nПроверка сторон треугольника Даны длины трех отрезков. Проверьте, могут ли они служить сторонами невырожденного треугольника, с учетом правила: каждая сторона должна быть меньше суммы двух других сторон.\nГадание с суммой делителей Напишите программу, которая позволит Маше гадать на числах. По введенному натуральному числу N программа должна вычислить сумму всех чисел, на которые N делится без остатка.\nЦветы На окошке стояло три цветочка, слева направо: герань (G), крокус (C) и фиалка (V). Каждое утро Маша меняла местами цветок, стоящий справа, с центральным цветком. А каждый вечер Таня меняла местами левый и центральный цветок. Требуется определить порядок цветов ночью после прошествия K дней.\nИзначальное состояние цветов: GCV (герань - крокус - фиалка).\nПроверка на простое число Напишите программу, которая позволяет пользователю ввести целое число и определить, является ли оно простым. Для определения простоты числа, проверьте, делится ли оно нацело только на 1 и само себя.\nПодсказка: Используйте циклы и операторы условия для реализации этой задачи.\nКалькулятор банковских процентов Создайте программу, которая помогает пользователям расчитать будущее значение вклада с учетом начальной суммы, процентной ставки и срока вложения. Учтите, что программа должна обрабатывать некорректные входные данные, такие как отрицательные значения.\nПодсказка: Используйте операторы условия для обработки некорректных входных данных и формулу для расчета будущей стоимости вклада.\nГенератор случайных чисел Напишите программу, которая генерирует случайное целое число в заданном диапазоне. Пользователь должен ввести минимальное и максимальное значения. Учтите обработку ошибочного ввода.\nПодсказка: Используйте функцию rand() для генерации случайных чисел и операторы условия для проверки корректности введенных данных.\nПодсчет гласных и согласных букв Создайте программу, которая позволяет пользователю ввести строку текста, а затем подсчитывает количество гласных и согласных букв в этой строке. Программа должна учитывать разные регистры (верхний и нижний).\nПодсказка: Используйте операторы условия и циклы для перебора символов строки и подсчета гласных и согласных букв.\nИгра \u0026ldquo;Камень, ножницы, бумага\u0026rdquo; с компьютером Напишите программу, которая позволяет пользователю играть в \u0026ldquo;Камень, ножницы, бумага\u0026rdquo; с компьютером. Программа должна генерировать случайный выбор для компьютера и определять победителя в каждом раунде игры.\nПодсказка: Используйте генерацию случайных чисел и операторы условия для определения победителя.\nЗаключение Эти задачи позволят читателям статьи практиковать операторы условия и циклы в C++ и учитывать обработку ошибочных входных данных.\n","date":"2023-11-05T00:00:00Z","image":"https://kotazzz.github.io/p/cpp04/00_placeholder_hu0bf8c09bd551b4c281835953d780ba29_43907_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/cpp04/","title":"C++: больше практических задач"},{"content":"Расширенные функции математики (библиотека cmath) C++ предоставляет богатую библиотеку для математических операций, которая включает в себя заголовочный файл cmath. В этой библиотеке содержатся различные математические функции, такие как sqrt (квадратный корень), sin (синус), cos (косинус), log (натуральный логарифм), и многие другие. Вот пример использования функции sqrt и формулы Герона для вычисления площади треугольника:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double a, b, c; cout \u0026lt;\u0026lt; \u0026#34;Введите длины сторон треугольника: \u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; double s, p; p = (a + b + c) / 2; // Полупериметр s = sqrt(p * (p - a) * (p - b) * (p - c)); // Формула Герона для площади cout \u0026lt;\u0026lt; \u0026#34;Площадь треугольника: \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } Функция Описание sqrt(x) Квадратный корень числа x. cbrt(x) Кубический корень числа x. pow(x, y) Возводит число x в степень y. exp(x) Вычисляет экспоненту (e^x). log(x) Натуральный логарифм числа x. log10(x) Десятичный логарифм числа x. fabs(x) Абсолютное значение числа x. ceil(x) Округляет число x до ближайшего большего целого. floor(x) Округляет число x до ближайшего меньшего целого. sin(x) Синус угла x (x в радианах). cos(x) Косинус угла x (x в радианах). tan(x) Тангенс угла x (x в радианах). asin(x) Арксинус числа x (возвращает угол в радианах). acos(x) Арккосинус числа x (возвращает угол в радианах). atan(x) Арктангенс числа x (возвращает угол в радианах). sinh(x) Гиперболический синус числа x. cosh(x) Гиперболический косинус числа x. tanh(x) Гиперболический тангенс числа x. fmod(x, y) Остаток от деления x на y. modf(x, \u0026amp;intPart) Разделяет число x на целую и дробную части. hypot(x, y) Гипотенуза прямоугольного треугольника. ldexp(x, exp) Умножает x на 2^exp. frexp(x, \u0026amp;exp) Разделяет число x на мантиссу и экспоненту. Генерация случайных чисел (рандом) C++ предоставляет библиотеку random, которая позволяет генерировать случайные числа. Она включает в себя классы и функции для работы с случайными числами. Вот пример игры \u0026ldquo;угадай число от 1 до 100\u0026rdquo; с использованием случайных чисел:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; int main() { srand(time(0)); // Инициализация генератора случайных чисел int secretNumber = rand() % 100 + 1; // Генерация случайного числа от 1 до 100 int guess; int attempts = 0; cout \u0026lt;\u0026lt; \u0026#34;Попробуйте угадать число от 1 до 100.\u0026#34; \u0026lt;\u0026lt; endl; do { cout \u0026lt;\u0026lt; \u0026#34;Ваш вариант: \u0026#34;; cin \u0026gt;\u0026gt; guess; attempts++; if (guess \u0026lt; secretNumber) { cout \u0026lt;\u0026lt; \u0026#34;Загаданное число больше.\u0026#34; \u0026lt;\u0026lt; endl; } else if (guess \u0026gt; secretNumber) { cout \u0026lt;\u0026lt; \u0026#34;Загаданное число меньше.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Поздравляем! Вы угадали число \u0026#34; \u0026lt;\u0026lt; secretNumber \u0026lt;\u0026lt; \u0026#34; с \u0026#34; \u0026lt;\u0026lt; attempts \u0026lt;\u0026lt; \u0026#34; попыток!\u0026#34; \u0026lt;\u0026lt; endl; } } while (guess != secretNumber); return 0; } В этом примере мы используем функцию rand() для генерации случайных чисел и инициализируем генератор случайных чисел с использованием текущего времени. Затем программа предлагает пользователю угадать число и дает подсказки, пока число не будет угадано.\n","date":"2023-11-04T00:00:00Z","image":"https://kotazzz.github.io/p/cpp01/00_placeholder_hu0bf8c09bd551b4c281835953d780ba29_43907_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/cpp01/","title":"C++: циклы и массивы"},{"content":"For Цикл for - это один из наиболее распространенных и удобных способов итерации в C++. Он позволяет вам выполнять повторяющиеся действия определенное количество раз или итерировать через последовательность элементов. Вот обзор синтаксиса и примеры использования цикла for.\nСинтаксис цикла for 1 2 3 for (инициализация; условие; обновление) { // Тело цикла } Инициализация: Этот блок выполняется один раз, в начале цикла. Он используется для инициализации переменных цикла. Условие: Это логическое выражение, которое проверяется перед каждой итерацией. Если условие истинно, цикл продолжает выполнение; в противном случае, он завершается. Обновление: Этот блок выполняется после каждой итерации и обычно используется для изменения переменных цикла. Тело цикла: Это блок кода, который будет выполняться в каждой итерации. Примеры Пример 1: Цикл for для итерации от 1 до 5 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; int main() { for (int i = 1; i \u0026lt;= 5; i++) { std::cout \u0026lt;\u0026lt; \u0026#34;Итерация \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } return 0; } 1 2 3 4 5 Итерация 1 Итерация 2 Итерация 3 Итерация 4 Итерация 5 В этом примере цикл for выполняет тело цикла 5 раз, начиная с i = 1, и увеличивая i на 1 в каждой итерации.\nПример 4: Использование цикла for для суммирования чисел от 1 до 100 1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; int main() { int sum = 0; for (int i = 1; i \u0026lt;= 100; i++) sum += i; std::cout \u0026lt;\u0026lt; \u0026#34;Сумма чисел от 1 до 100: \u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; std::endl; return 0; } 1 Сумма чисел от 1 до 100: 5050 Этот пример демонстрирует использование цикла for для суммирования чисел от 1 до 100.\nЗадачи Сумма чисел: Напишите программу, которая находит сумму всех чисел от 1 до N, где N - введенное пользователем число. Факториал: Разработайте программу для вычисления факториала числа N, используя цикл for. Таблица умножения: Создайте таблицу умножения для определенного числа, например, для числа 7, выводя результаты от 7 1 до 7 10. Подсчет четных чисел: Напишите программу, которая подсчитывает количество четных чисел в диапазоне от M до N, где M и N - введенные пользователем значения. Рисование геометрических фигур: Используйте цикл for для рисования геометрических фигур, таких как треугольники или квадраты, с заданными размерами. Работа с массивами: Итерируйтесь по элементам массива и выполните определенные операции, такие как поиск среднего значения, нахождение максимального/минимального элемента и другие. Генерация последовательности чисел: Создайте программу, которая генерирует последовательность чисел, например, все простые числа в определенном диапазоне. Таблица степеней двойки: Выведите таблицу степеней двойки от 2^0 до 2^N. Подсчет гласных букв: Подсчитайте количество гласных букв в строке, используя цикл for. Важные замечания Инициализация, условие и обновление в цикле for могут быть любыми выражениями. Переменные, объявленные в блоке инициализации, видны только в пределах цикла. Если условие цикла всегда истинно, это приведет к бесконечному циклу. Цикл for - мощный инструмент для итерации и выполнения повторяющихся действий в C++. Он может использоваться для различных задач, и вы можете настраивать его в соответствии с вашими потребностями.\nЦикл while и do while Цикл while Цикл while выполняет блок кода, пока заданное условие остается истинным. Условие проверяется до выполнения блока кода, и если оно ложное с самого начала, блок кода ни разу не выполнится.\nПример while 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; int main() { int i = 1; while (i \u0026lt;= 5) { std::cout \u0026lt;\u0026lt; \u0026#34;Число \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; i++; } return 0; } 1 2 3 4 5 Число 1 Число 2 Число 3 Число 4 Число 5 Цикл do-while Цикл do-while очень похож на while, но он гарантирует, что блок кода выполнится хотя бы один раз, даже если условие с самого начала ложное. Условие проверяется после выполнения блока кода.\nПример do-while 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; int main() { int i = 1; do { std::cout \u0026lt;\u0026lt; \u0026#34;Число \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; i++; } while (i \u0026lt;= 5); return 0; } 1 2 3 4 5 Число 1 Число 2 Число 3 Число 4 Число 5 Задачи, решаемые и циклом while, и циклом do-while Сумма чисел: Напишите программу для вычисления суммы чисел от 1 до N с использованием как цикла while, так и цикла do-while. Четные числа: Выведите все четные числа от M до N с использованием как цикла while, так и цикла do-while. Проверка на простое число: Напишите программу для определения, является ли число N простым, используя как цикл while, так и цикл do-while. Массивы Введение Массивы - это одна из наиболее важных структур данных в программировании. Они представляют собой упорядоченный набор элементов одного типа, размещенных в памяти последовательно. Массивы позволяют хранить и обрабатывать множество данных одного типа, и они используются повсеместно в программировании, предоставляя доступ к данным в удобной форме.\nДавайте рассмотрим аналогию из реальной жизни, чтобы лучше понять, как работают массивы. Представьте себе библиотеку, где книги хранятся на полках. Каждая книга имеет свой собственный номер, который указывает на ее местоположение. В этой аналогии:\nБиблиотека - это массив, который содержит книги (элементы). Полки - это местоположение каждого элемента массива, которое определяется его индексом. Номер книги - это индекс элемента массива, с помощью которого мы можем найти и получить доступ к элементу. В программировании массивы работают по аналогии с этой аналогией. Они позволяют нам хранить и управлять большими объемами данных. Массивы обладают следующими ключевыми характеристиками:\nТип данных: Все элементы массива должны быть одного и того же типа данных (например, целые числа, числа с плавающей запятой, символы и т. д.). Индексы: Элементы массива упорядочены и доступ к ним осуществляется по индексам. Индексы начинаются с 0 (первый элемент) и увеличиваются на 1. Размер: Массив имеет фиксированный размер, который определяется при его создании. Размер массива не может изменяться во время выполнения программы. Память: Элементы массива располагаются последовательно в памяти, что обеспечивает быстрый доступ к данным. Операции над массивами Объявление и инициализация массивов Для создания массива в C++ вы должны указать его тип, имя и размер. Вот как это выглядит:\n1 тип_данных имя_массива[размер]; 1 2 3 int num[5]; // Объявление массива целых чисел размером 5 double values[10]; // Объявление массива чисел с плавающей запятой размером 10 char my_chars[26]; // Объявление массива символов размером 26 Вы можете инициализировать массив сразу при объявлении:\n1 int nums[] = {1, 2, 3, 4, 5}; // Инициализация массива целых чисел Доступ к элементам массива Доступ к элементам массива осуществляется с использованием индекса, который указывает на конкретный элемент массива. Индексы начинаются с 0.\n1 int val = nums[2]; // Получение значения третьего элемента массива (индекс 2) Итерация по массиву Чтобы пройти по всем элементам массива, вы можете использовать цикл, такой как for или while. Вот пример использования цикла for:\n1 2 3 for (int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; числа[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } Задачи для практики Сумма элементов: Напишите программу, которая вычисляет сумму всех элементов в массиве. Поиск максимума и минимума: Найдите максимальный и минимальный элементы в массиве. ","date":"2023-11-03T00:00:00Z","image":"https://kotazzz.github.io/p/cpp01/00_placeholder_hu0bf8c09bd551b4c281835953d780ba29_43907_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/cpp01/","title":"C++: циклы и массивы"},{"content":"В программировании, ветвление - это важная концепция, которая позволяет программе принимать решения и выполнять разные действия в зависимости от различных условий. В C++, для этой цели используются операторы ветвления, такие как if, else, и else if.\nКогда нам нужно ветвление? Ветвление становится необходимым, когда в программе возникают ситуации, в которых необходимо выполнять разные действия в зависимости от текущей ситуации или входных данных. Рассмотрим пример из реальной жизни:\nПример: План действий при плохой погоде Когда человек выходит из дома, он может столкнуться с разной погодой. Если на улице дождь, человек возможно захочет взять зонтик, чтобы не промокнуть. Если на улице снег, то, возможно, потребуется одеться потеплее. Если погода хорошая, человек может просто выйти на улицу. Таким образом, мы имеем разные действия в зависимости от условий погоды.\nОператоры ветвления в C++ Для реализации ветвления в C++, используются следующие ключевые слова:\nif: Позволяет выполнить блок кода, если заданное условие истинно. else: Позволяет выполнить блок кода, если условие в операторе if ложно. else if: Позволяет проверить дополнительное условие, если первое условие в операторе if ложно. Вот синтаксис операторов условия if, if-else, if-else if-else, а также примеры использования с фигурными скобками {} и без них:\nОператор if:\n1 2 3 if (условие) { // Код, который выполняется, если условие истинно } Пример без фигурных скобок: 1 2 3 if (условие) // Этот код выполнится, если условие истинно // Фигурные скобки можно не писать, если выполняется одно действие Оператор if-else:\n1 2 3 4 5 if (условие) { // Код, который выполняется, если условие истинно } else { // Код, который выполняется, если условие ложно } Оператор if-else if-else:\n1 2 3 4 5 6 7 if (условие1) { // Код, который выполняется, если условие1 истинно } else if (условие2) { // Код, который выполняется, если условие2 истинно } else { // Код, который выполняется, если все условия ложны } Примечание:\nИспользование фигурных скобок {} рекомендуется для ясности и предотвращения ошибок в коде, особенно если блоки кода в операторах условия if, else, и else if состоят из нескольких операторов. Если внутри оператора условия должен быть выполнен только один оператор (или выражение), то фигурные скобки не обязательны, но они улучшают читаемость кода. Как строится условие и операторы сравнения Условие в операторе if или других операторах условия строится с использованием операторов сравнения. Операторы сравнения позволяют сравнивать значения и переменные в различных способах и определять, истинно ли условие. Вот основные операторы сравнения в C++:\nОператор Описание Пример Результат == Равно (сравнивает два значения на равенство) 5 == 5 true != Не равно (сравнивает два значения на неравенство) 3 != 7 true \u0026lt; Меньше (проверяет, если левое значение меньше правого) 4 \u0026lt; 9 true \u0026gt; Больше (проверяет, если левое значение больше правого) 8 \u0026gt; 2 true \u0026lt;= Меньше или равно (проверяет, если левое значение меньше или равно правому) 5 \u0026lt;= 5 true \u0026gt;= Больше или равно (проверяет, если левое значение больше или равно правому) 7 \u0026gt;= 6 true Примеры условий с использованием операторов сравнения:\n1 2 3 4 5 6 7 8 9 10 11 12 13 int x = 5, y = 10; if (x == y) { // Выполняется, если x равно y } if (x \u0026lt; y) { // Выполняется, если x меньше y } if (x != y) { // Выполняется, если x не равно y } Условия, построенные с использованием этих операторов сравнения, могут принимать значения true или false, в зависимости от того, удовлетворяются ли они.\nПримеры Пример 1: погода 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { string weather = \u0026#34;дождь\u0026#34;; // Погода: дождь, снег, хорошая if (weather == \u0026#34;дождь\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Возьмите зонтик.\u0026#34; \u0026lt;\u0026lt; endl; } else if (weather == \u0026#34;снег\u0026#34;) { cout \u0026lt;\u0026lt; \u0026#34;Оденьтесь потеплее.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;Можете выйти на улицу.\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } В этом примере:\nМы объявили переменную weather, которая хранит текущую погоду. Затем мы используем операторы if, else if и else для выполнения разных действий в зависимости от значения переменной weather. В зависимости от значения weather, программа выводит соответствующее сообщение. Это простой пример ветвления в C++, который позволяет программе принимать решения на основе входных данных или условий\nПример 2: Проверка четности числа 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int number; cout \u0026lt;\u0026lt; \u0026#34;Введите целое число: \u0026#34;; cin \u0026gt;\u0026gt; number; if (number % 2 == 0) { cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; является четным числом.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; number \u0026lt;\u0026lt; \u0026#34; является нечетным числом.\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Объяснение:\nМы объявляем переменную number и запрашиваем у пользователя ввести целое число. Затем мы используем оператор if, чтобы проверить, делится ли введенное число нацело на 2. Если да, это означает, что число четное, и соответствующее сообщение выводится. Если число не делится нацело на 2 (остаток от деления не равен 0), это означает, что число нечетное, и выводится соответствующее сообщение. Пример 3: Определение наименьшего из трех чисел 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a, b, c; cout \u0026lt;\u0026lt; \u0026#34;Введите три целых числа: \u0026#34;; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c; if (a \u0026lt; b \u0026amp;\u0026amp; a \u0026lt; c) { cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; - наименьшее число.\u0026#34; \u0026lt;\u0026lt; endl; } else if (b \u0026lt; c) { cout \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#34; - наименьшее число.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34; - наименьшее число.\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } Объяснение:\nМы объявляем переменные a, b и c, и просим пользователя ввести три целых числа. Затем мы используем операторы if, else if и else, чтобы сравнить значения переменных и определить наименьшее из них. В зависимости от результата сравнения выводится сообщение с наименьшим числом. Задачи для практики Проверка на четность/нечетность: Напишите программу, которая запрашивает у пользователя целое число и выводит сообщение о том, является ли это число четным или нечетным.\nОпределение максимального числа: Попросите пользователя ввести три целых числа, а затем определите и выведите наибольшее из них.\nКалькулятор: Создайте программу-калькулятор, которая запрашивает у пользователя два числа и операцию (сложение, вычитание, умножение, деление), а затем выполняет выбранную операцию и выводит результат.\nОценки в школе: Напишите программу, которая просит пользователя ввести свою оценку (A, B, C, D, F) и выводит сообщение о его успехах в школе.\nПроверка на делимость: Попросите пользователя ввести целое число и проверьте, делится ли оно на 3 без остатка. Выведите соответствующее сообщение.\nОпределение времени суток: Спросите пользователя, который вводит текущее время в часах (от 0 до 23), и определите, в какую часть дня (утро, день, вечер, ночь) оно попадает.\nКомпаратор строк: Напишите программу, которая сравнивает две строки, введенные пользователем, и сообщает, являются ли они одинаковыми или разными.\nУсловия с логическими операторами: Создайте программу, которая проверяет, вводит ли пользователь целое число, которое одновременно больше 10 и меньше 100.\nЭти задачи помогут вам отработать навыки использования операторов условия и операторов сравнения в C++.\n","date":"2023-11-02T00:00:00Z","image":"https://kotazzz.github.io/p/cpp02/00_placeholder_hu0bf8c09bd551b4c281835953d780ba29_43907_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/cpp02/","title":"C++: условия"},{"content":"C++ - это универсальный и мощный язык программирования, который используется для разработки различных видов приложений, начиная от игр и системного программирования, и заканчивая веб-разработкой. В этой статье мы начнем с основ и постепенно погрузимся в мир программирования на C++.\nСтруктура программы Программа на C++ обычно состоит из следующих основных элементов:\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { // Ваш код здесь return 0; } Давайте разберемся, что делает каждая часть:\n#include \u0026lt;iostream\u0026gt;: Эта строка включает библиотеку iostream, которая предоставляет функции для ввода и вывода данных, а так же некоторые другие.\nusing namespace std;: Эта строка позволяет нам использовать объекты и функции из стандартного пространства имен std без явного указания. Без этой строчки использование многих функций будет выглядеть как std::cin, std::cout и так далее\nint main() { ... }: Это объявление функции main, которая является точкой входа в программу. Здесь вы размещаете код вашей программы. Программа начнет работать именно с этого места\nПример программы \u0026ldquo;Hello, World!\u0026rdquo; на C++ 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } Как только вы скомпилируете и запустите эту программу, вы увидите на экране текст \u0026ldquo;Hello, World!\u0026rdquo;.\nРабота с русским текстом Если вы хотите работать с русским текстом, иногда необходимо настроить вывод в консоль. Например, чтобы корректно отображать кириллицу. Для этого вы можете использовать функцию setlocale:\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { setlocale(LC_ALL, \u0026#34;Russian\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;Привет, мир!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } Это позволит вашей программе корректно работать с русским текстом.\nПеременные Переменные - это контейнеры, которые хранят данные. В C++ есть разные типы переменных, и каждый из них предназначен для хранения разных видов данных. Вот некоторые из наиболее распространенных типов переменных:\nТип данных Размер (в байтах) Пример значения Описание int 4 42 Целое число double 8 3.14 Десятичное число с плавающей точкой char 1 \u0026lsquo;A\u0026rsquo; Один символ bool 1 true/false Логическое значение (истина/ложь) string Различный \u0026ldquo;Пример\u0026rdquo; Строка символов Примеры использования переменных:\n1 2 3 4 5 int age = 30; // Переменная \u0026#34;age\u0026#34; типа int с значением 30 double pi = 3.141592; // Переменная \u0026#34;pi\u0026#34; типа double с значением 3.141592 char grade = \u0026#39;A\u0026#39;; // Переменная \u0026#34;grade\u0026#34; типа char с значением \u0026#39;A\u0026#39; bool isRaining = false; // Переменная \u0026#34;isRaining\u0026#34; типа bool с значением false string name = \u0026#34;Иван\u0026#34;; // Переменная \u0026#34;name\u0026#34; типа string с значением \u0026#34;Иван\u0026#34; Ввод данных Мы можешь выводить текст и хранить данные. Однако у нас есть так же необходимость управлять программой во время ее работы. Чтобы получить данные от пользователя, вы можете использовать cin. Например, чтобы попросить пользователя ввести свое имя:\n1 2 3 4 5 string name; // Пример инициализации переменной без начального значения cout \u0026lt;\u0026lt; \u0026#34;Введите ваше имя: \u0026#34;; cin \u0026gt;\u0026gt; name; cout \u0026lt;\u0026lt; \u0026#34;Привет, \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; endl; Пользователю будет предложено ввести свое имя, и программа сохранит его в переменной name, которую затем можно использовать для вывода приветствия. Это лишь вводное руководство по C++. В дальнейших статьях мы рассмотрим более сложные концепции, такие как условные операторы,\nОперации Математические операции - это фундаментальная часть программирования, и C++ предоставляет широкий набор операторов для выполнения различных вычислений. В этой части статьи мы рассмотрим базовые математические операции, а также операторы инкремента и декремента.\nБазовые математические операции В С++ используется 5 базовых операторов\nОператор Описание Пример + Сложение int sum = 5 + 3; - Вычитание int difference = 10 - 4; * Умножение int product = 6 * 7; / Деление double quotient = 9.0 / 2.0; % Остаток от деления int remainder = 10 % 3; Инкремент и декремент Операторы инкремента (++) и декремента (\u0026ndash;) используются для увеличения или уменьшения значения переменной на 1 соответственно. Эти операторы могут применяться как в префиксной, так и в постфиксной форме.\nПрефиксная инкремента (++a) и декремента (\u0026ndash;a) В префиксной форме значение переменной увеличивается или уменьшается до выполнения других операций.\nПример:\n1 2 int a = 5; int b = ++a; // a увеличится до 6, b станет равным 6 Постфиксная инкремента (a++) и декремента (a\u0026ndash;) В постфиксной форме значение переменной изменяется после выполнения других операций.\nПример:\n1 2 int x = 5; int y = x++; // y получит значение 5, затем x увеличится до 6 Разница между префиксной и постфиксной формой Разница между префиксной и постфиксной формой инкремента (декремента) заключается в том, когда происходит изменение значения переменной. В префиксной форме значение меняется до использования переменной, а в постфиксной форме - после.\nПрефиксный инкремент (декремент):\nСначала изменяет значение переменной. Затем использует новое значение. Постфиксный инкремент (декремент):\nСначала использует текущее значение переменной. Затем изменяет значение переменной. Обратите внимание на порядок выполнения в обоих случаях. Выбор между префиксной и постфиксной формой зависит от конкретной задачи и требований вашей программы.\nЗачади для практики Приветствие пользователя: Напишите программу, которая запрашивает у пользователя его имя и затем приветствует его.\n1 2 Введите ваше имя Анна Привет, Анна! Калькулятор: Создайте программу-калькулятор, которая позволяет пользователю ввести два числа и выводит результаты разных операций (сложение, вычитание, умножение, деление) на экран.\nКонвертер температуры: Напишите программу, которая конвертирует температуру из градусов Цельсия в градусы Фаренгейта. Пользователь должен ввести температуру в градусах Цельсия, и программа должна вывести эквивалент в градусах Фаренгейта, используя формулу: F = (C * 9/5) + 32.\nУспешное решение этих задач поможет вам лучше понять основы C++ и начать практиковаться в программировании.\n","date":"2023-11-01T00:00:00Z","image":"https://kotazzz.github.io/p/cpp01/00_placeholder_hu0bf8c09bd551b4c281835953d780ba29_43907_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/cpp01/","title":"Введение в C++"},{"content":"Введение в ООП Что такое ООП ООП, или объектно-ориентированное программирование, это подход к программированию, основанный на использовании объектов, которые взаимодействуют друг с другом для решения задач.\nООП как язык - каждый язык имеет свой набор правил и способов выражения мыслей. Аналогично, ООП имеет свои правила и способы выражения кода. ООП как машина - каждый объект является отдельной частью, которая работает вместе с другими частями для выполнения задачи. Аналогично, каждый объект в ООП является отдельной частью, которая работает вместе с другими объектами для выполнения задачи. ООП как дом - каждый объект является отдельной комнатой в доме, которая имеет свою уникальную функцию. Аналогично, каждый объект в ООП является отдельной частью программы, которая имеет свою уникальную функцию. Принципы ООП Инкапсуляция: объединение данных и методов, которые работают с этими данными, в одном классе и скрытие их от остального кода. Наследование: возможность создавать новые классы на основе уже существующих и наследовать их свойства и методы. Полиморфизм: возможность объектов с одинаковым интерфейсом иметь разные реализации методов. Еще два принципа ООП, которые не были упомянуты ранее: абстракция и композиция.\nАбстракция: создание упрощенной модели объекта, которая позволяет сосредоточиться на основных характеристиках объекта, игнорируя мелкие детали. Абстракция позволяет разрабатывать более гибкие и масштабируемые программы. Композиция: создание нового объекта путем объединения уже существующих объектов. Композиция позволяет создавать объекты, которые могут выполнять сложные задачи, используя функциональность других объектов. В Python поддерживаются все принципы ООП, включая инкапсуляцию, наследование, полиморфизм, абстракцию и композицию. Кроме того, в Python есть множество инструментов и библиотек, которые облегчают работу с объектами и позволяют создавать более эффективные и гибкие программы.\nПреимущества и недостатки ООП ✅ Преимущества ООП Более структурированный и модульный код Повторное использование кода Улучшенная поддерживаемость ❎ Недостатки ООП Высокий уровень абстракции может усложнить понимание кода Добавление новых функций может потребовать много времени и усилий Другие подходы к программированию В дополнение к ООП, существуют и другие подходы к программированию:\nПроцедурное программирование - это подход, который фокусируется на выполняемых процедурах и функциях. Функциональное программирование - это подход, который фокусируется на использовании функций. Логическое программирование - это подход, который фокусируется на использовании формальной логики для решения задач. Каждый из этих подходов имеет свои преимущества и недостатки, и выбор подхода зависит от конкретных потребностей проекта.\nПарадигма программирования Общее использование Основные характеристики Преимущества Недостатки Объектно-ориентированное программирование Широко используется в разработке программного обеспечения Использует объекты для представления данных и поведения Инкапсуляция, Наследование, Полиморфизм, Абстракция, Композиция Высокий уровень абстракции может усложнить понимание кода Процедурное программирование Используется для крупномасштабных проектов, где важна организация кода Использует процедуры и функции для представления поведения Модульность, Повторное использование, Легкость поддержки Может быть менее эффективным, чем другие парадигмы Функциональное программирование Используется для математических и научных вычислений Сфокусирован на вычислении функций и избегает изменения состояния и изменяемых данных Неизменяемость, Референциальная прозрачность, Функции высшего порядка Может быть сложным для изучения и понимания Логическое программирование Используется для искусственного интеллекта и систем на основе знаний Использует формальную логику для представления и решения задач Декларативность, Легкость отладки, Может обрабатывать сложные задачи Ограниченная поддержка для нелогических задач, Может быть менее эффективным, чем другие парадигмы Базовые определения Класс - это шаблон для создания объектов, а объект - это экземпляр класса.\nМетоды - это функции, принадлежащие определенному классу.\nАтрибуты - это переменные, принадлежащие определенному объекту. Переменные - это временные хранилища для значений.\nООП в python Как создать класс в Python Для создания класса в Python используется ключевое слово class, за которым следует имя класса.\nПример класса:\n1 2 3 4 5 6 7 8 9 class MyClass: def __init__(self, name): self.name = name def say_hello(self): print(f\u0026#34;Hello, {self.name}!\u0026#34;) my_object = MyClass(\u0026#34;World\u0026#34;) my_object.say_hello() # Output: Hello, World! Другие примеры 1 2 3 4 5 6 7 8 9 10 11 12 13 class Car: def __init__(self, color, model): self.color = color self.model = model self.speed = 0 # начальная скорость self.position = 0 # начальная позиция def go(self, speed): self.speed = speed # задать скорость def get_position(self): self.position += self.speed # увеличить позицию на текущую скорость return self.position # вернуть позицию 1 2 3 4 5 6 7 8 9 10 11 12 13 class Robot: def __init__(self, name): self.name = name self.memory = [] # пустой список для запоминания текста def say(self, text): print(text) def remember(self, text): self.memory.append(text) # добавить текст в список запомненного def retell(self): print(\u0026#39; \u0026#39;.join(self.memory)) # соединить все тексты из списка в одну строку и вывести ее 1 2 3 4 5 6 7 8 9 10 11 12 class Student: def __init__(self, name, grade): self.name = name self.grade = grade class School: def __init__(self, name): self.name = name self.students = [] # пустой список учеников def add_student(self, student): self.students.append(student) # добавить ученика в список 1 2 3 4 5 6 class Person: def __init__(self, name): self.name = name def say_hello(self): print(\u0026#39;Hello, my name is\u0026#39;, self.name) Классы Car, Robot, School и Person являются примерами создания классов в Python. В блоке кода, представляющем каждый класс, описываются его атрибуты и методы.\nCar - класс для создания объектов машин, у которых есть цвет, модель, скорость и позиция. Метод go задает скорость машины, а метод get_position возвращает текущую позицию машины.\nRobot - класс для создания объектов роботов, у которых есть имя и список запомненных текстов. Метод say выводит заданный текст, метод remember добавляет текст в список запомненных, а метод retell выводит все запомненные тексты в одну строку.\nSchool - класс для создания объектов школ, у которых есть название и список учеников. Метод add_student добавляет ученика в список.\nPerson - класс для создания объектов людей, у которых есть имя. Метод say_hello выводит приветствие с именем объекта.\nПример использования этих классов:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # Создаем объекты классов car = Car(\u0026#39;Red\u0026#39;, \u0026#39;Tesla\u0026#39;) robot = Robot(\u0026#39;R2D2\u0026#39;) school = School(\u0026#39;School #1\u0026#39;) person = Person(\u0026#39;John\u0026#39;) # Используем методы объектов car.go(60) print(car.get_position()) robot.say(\u0026#39;Hello, World!\u0026#39;) robot.remember(\u0026#39;Buy milk\u0026#39;) robot.remember(\u0026#39;Feed the cat\u0026#39;) robot.retell() student1 = Student(\u0026#39;Alice\u0026#39;, 9) student2 = Student(\u0026#39;Bob\u0026#39;, 10) school.add_student(student1) school.add_student(student2) print(school.students) person.say_hello() Результат выполнения кода:\n1 2 3 4 5 60 Hello, World! Buy milk Feed the cat [\u0026lt;__main__.Student object at 0x7f8c3f12de10\u0026gt;, \u0026lt;__main__.Student object at 0x7f8c3f12df98\u0026gt;] Hello, my name is John В этом примере мы создали объекты классов Car, Robot, School и Person, и использовали их методы для задания скорости машины, запоминания текста роботом, добавления учеников в школу и приветствия человека.\nТаблица всех dunder методов и их описания В ООП классы используются для создания объектов, которые могут быть использованы в программе. Однако, что делать, если мы хотим, чтобы объекты могли складываться, вычитаться или выполнять код при вызове? В Python для этого существуют специальные методы, называемые \u0026ldquo;dunder methods\u0026rdquo;, которые позволяют определить поведение объектов при выполнении различных операций. Например, метод add позволяет определить, как складывать два объекта, а метод call позволяет определить, как выполнять код при вызове объекта. Решение этих задач и многое другое будет рассмотрено в данном курсе. Dunder-методы это методы, которые начинаются и заканчиваются на два символа подчеркивания. Они используются для реализации различных магических методов.\nМетод Описание __init__(self, ...) Инициализация объекта __str__(self) Возвращает строковое представление объекта __repr__(self) Возвращает строковое представление объекта для отладки __len__(self) Возвращает длину объекта __add__(self, other) Возвращает результат сложения двух объектов __sub__(self, other) Возвращает результат вычитания двух объектов __mul__(self, other) Возвращает результат умножения двух объектов __truediv__(self, other) Возвращает результат деления двух объектов __floordiv__(self, other) Возвращает результат целочисленного деления двух объектов __mod__(self, other) Возвращает результат операции модуля двух объектов __pow__(self, other) Возвращает результат возведения одного объекта в степень другого __lt__(self, other) Возвращает True, если текущий объект меньше, чем объект other __le__(self, other) Возвращает True, если текущий объект меньше или равен объекту other __eq__(self, other) Возвращает True, если текущий объект равен объекту other __ne__(self, other) Возвращает True, если текущий объект не равен объекту other __gt__(self, other) Возвращает True, если текущий объект больше, чем объект other __ge__(self, other) Возвращает True, если текущий объект больше или равен объекту other __hash__(self) Возвращает хеш-значение объекта __bool__(self) Возвращает False, если объект пустой, и True, если нет __getattr__(self, name) Вызывается при обращении к несуществующему атрибуту объекта __setattr__(self, name, value) Вызывается при установке значения атрибута объекта __delattr__(self, name) Вызывается при удалении атрибута объекта __call__(self, ...) Вызывается при вызове объекта как функции __enter__(self) Вызывается при входе в блок контекстного менеджера __exit__(self, exc_type, exc_val, exc_tb) Вызывается при выходе из блока контекстного менеджера __iter__(self) Возвращает итератор для объекта __next__(self) Возвращает следующий элемент итератора __getitem__(self, key) Возвращает элемент по индексу или ключу __setitem__(self, key, value) Устанавливает значение элемента по индексу или ключу __delitem__(self, key) Удаляет элемент по индексу или ключу __contains__(self, item) Возвращает True, если объект содержит элемент item __index__(self) Возвращает целочисленное представление объекта __reversed__(self) Возвращает обратный итератор для объекта __enter__(self) Вызывается при входе в блок контекстного менеджера __exit__(self, exc_type, exc_val, exc_tb) Вызывается при выходе из блока контекстного менеджера __dir__(self) Возвращает список атрибутов объекта __format__(self, format_spec) Форматирует объект с помощью указанной спецификации формата __bytes__(self) Возвращает байтовое представление объекта __class__(self) Возвращает ссылку на класс объекта __instancecheck__(self, instance) Возвращает True, если объект является экземпляром указанного класса __subclasscheck__(self, subclass) Возвращает True, если класс является наследником указанного класса __getattribute__(self, name) Вызывается при обращении к атрибуту объекта __setattr__(self, name, value) Вызывается при установке значения атрибута объекта __delattr__(self, name) Вызывается при удалении атрибута объекта __dir__(self) Возвращает список атрибутов объекта __enter__(self) Вызывается при входе в блок контекстного менеджера __exit__(self, exc_type, exc_val, exc_tb) Вызывается при выходе из блока контекстного менеджера __get__(self, instance, owner) Возвращает значение атрибута __set__(self, instance, value) Устанавливает значение атрибута __delete__(self, instance) Удаляет значение атрибута В чем разница между init и new? __init__ - это магический метод, который вызывается при создании нового объекта класса. __new__ - это метод, который создает новый объект класса.\nSelf self - это параметр метода, который ссылается на экземпляр класса, для которого вызывается метод. Он используется для доступа к атрибутам и методам объекта. Когда мы вызываем метод на объекте, Python автоматически передает этот объект в качестве первого параметра метода, используя параметр self. Это позволяет нам оперировать данными конкретного объекта и изменять их внутри методов. Без параметра self мы бы не имели доступа к атрибутам и методам объекта и не могли бы изменять их значения.\nself - это ссылка на текущий объект. self используется для доступа к атрибутам и методам объекта.\nДекоратор @property @property - это декоратор, который позволяет использовать метод как атрибут.\nДля использования декоратора @property необходимо определить метод с этим декоратором.\nПример класса с использованием декоратора @property:\n1 2 3 4 5 6 7 8 9 10 11 12 class Rectangle: def __init__(self, length, width): self.length = length self.width = width @property def area(self): return self.length * self.width @property def perimeter(self): return 2 * (self.length + self.width) Здесь класс Rectangle имеет два атрибута - length и width, которые задают длину и ширину прямоугольника соответственно. Декоратор @property используется для создания атрибутов area и perimeter, которые вычисляют площадь и периметр прямоугольника соответственно.\nПример использования класса:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt;\u0026gt;\u0026gt; r = Rectangle(4, 5) \u0026gt;\u0026gt;\u0026gt; r.length 4 \u0026gt;\u0026gt;\u0026gt; r.width 5 \u0026gt;\u0026gt;\u0026gt; r.area 20 \u0026gt;\u0026gt;\u0026gt; r.perimeter 18 \u0026gt;\u0026gt;\u0026gt; r.length = 6 \u0026gt;\u0026gt;\u0026gt; r.width = 7 \u0026gt;\u0026gt;\u0026gt; r.area 42 \u0026gt;\u0026gt;\u0026gt; r.perimeter 26 Здесь мы создаем экземпляр класса Rectangle с длиной 4 и шириной 5, и затем используем атрибуты length, width, area и perimeter для получения соответствующих значений. Затем мы меняем значения атрибутов length и width, и снова используем атрибуты area и perimeter, чтобы получить новые значения.\nНаследование Наследование - это механизм, позволяющий создавать новый класс на основе существующего.\nДля использования наследования необходимо указать базовый класс в определении нового класса.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Animal: def __init__(self, name, sound): self.name = name self.sound = sound def make_sound(self): print(f\u0026#39;{self.name} издает звук \u0026#34;{self.sound}\u0026#34;\u0026#39;) class Cat(Animal): def __init__(self, name): super().__init__(name, \u0026#34;Мяу\u0026#34;) def purr(self): print(f\u0026#39;{self.name} мурлычет\u0026#39;) class Dog(Animal): def __init__(self, name): super().__init__(name, \u0026#34;Гав\u0026#34;) def wag_tail(self): print(f\u0026#39;{self.name} виляет хвостом\u0026#39;) cat = Cat(\u0026#34;Барсик\u0026#34;) cat.make_sound() cat.purr() dog = Dog(\u0026#34;Шарик\u0026#34;) dog.make_sound() dog.wag_tail() В этом примере мы определяем базовый класс Animal, который имеет два атрибута - name и sound - и метод make_sound(), который выводит сообщение со звуком, издаваемым животным.\nЗатем мы определяем два класса, Cat и Dog, которые наследуются от Animal. Каждый из этих классов переопределяет метод __init__(), чтобы задать соответствующий звук, и добавляет свой собственный метод - purr() для Cat и wag_tail() для Dog.\nЗатем мы создаем экземпляры классов Cat и Dog, и вызываем методы make_sound(), purr() и wag_tail() для каждого из них. Это демонстрирует, как наследование позволяет создавать новые классы на основе существующих и добавлять им собственные методы и атрибуты.\nСоветы и частые ошибки при создании классов Советы при создании классов Создавайте классы, которые отвечают только за одну задачу, и следуйте принципу единственной ответственности. Используйте наследование, чтобы избежать дублирования кода и упростить его поддержку. Используйте полиморфизм, чтобы обеспечить гибкость кода и упростить его использование. Используйте инкапсуляцию, чтобы скрыть детали реализации и обеспечить безопасность кода. Помните, что классы должны моделировать реальные объекты и процессы, а не только выполнять задачи. Документируйте каждый класс и его методы, чтобы облегчить его использование другими разработчиками. Частые ошибки при создании классов Одной из частых ошибок при создании классов является создание слишком сложных и неструктурированных классов.\nЧтобы избежать создания слишком сложных и неструктурированных классов, можно использовать следующие советы:\nРазбейте класс на более мелкие подклассы, каждый из которых решает отдельную задачу. Используйте наследование, чтобы избежать дублирования кода. Избегайте сильной связности между классами, чтобы классы были более переносимыми и гибкими. Не добавляйте в классы функциональность, которая не относится к их основной задаче. Избегайте создания слишком многих методов и атрибутов в классе, чтобы класс был проще в использовании и понимании. Используйте исключения, чтобы сообщать об ошибках внутри класса, вместо того, чтобы просто возвращать ошибочное значение. Разделяйте классы на слои, чтобы каждый слой решал свою задачу, и классы внутри слоя имели схожую функциональность. Особенности ООП в Python Одной из особенностей ООП в Python является отсутствие инкапсуляции в чистом виде. В Python нет специальных модификаторов доступа к атрибутам и методам объекта, и все они по умолчанию являются открытыми. Однако, существует соглашение об именовании, которое указывает на то, что атрибуты и методы, которые начинаются с символа подчеркивания, не должны использоваться вне класса. Это соглашение не является обязательным и может быть нарушено, но его соблюдение делает код более понятным и удобочитаемым.\nЕще одной особенностью ООП в Python является наличие множественного наследования. В Python классы могут наследоваться от нескольких базовых классов, что позволяет создавать более гибкие и мощные иерархии классов. Однако, множественное наследование может привести к сложностям в понимании кода и конфликтам имен атрибутов и методов.\nЕще одной особенностью ООП в Python является наличие магических методов, которые позволяют определять поведение объектов в различных ситуациях. Например, метод __str__ определяет строковое представление объекта, а метод __len__ определяет длину объекта. Магические методы позволяют создавать более гибкие и мощные объекты, но их неправильное использование может привести к сложностям в понимании кода.\nВ Python также есть возможность использовать декораторы, которые позволяют модифицировать поведение методов и классов. Например, декоратор @property позволяет использовать метод как атрибут, а декоратор @staticmethod позволяет определить статический метод, который не имеет доступа к атрибутам и методам объекта.\nКроме того, Python поддерживает динамическое создание атрибутов и методов объектов, что позволяет создавать более гибкие и динамичные программы. Однако, динамическое создание атрибутов и методов может привести к сложностям в понимании кода и его отладке.\nНаконец, Python поддерживает возможность перегрузки операторов, что позволяет определять поведение объектов при использовании стандартных операторов, таких как +, -, * и т.д. Перегрузка операторов позволяет создавать более удобный и понятный код, но ее неправильное использование может привести к сложностям\nПримеры использования ООП Примеры использования ООП в Python ООП может быть использован для создания различных программ, таких как игры, приложения и веб-сайты.\nИтоги Мы рассмотрели основы ООП в Python, включая классы и объекты, наследование, полиморфизм и инкапсуляцию. Также мы рассмотрели некоторые советы и частые ошибки при создании классов, а также особенности ООП в Python, такие как отсутствие инкапсуляции в чистом виде, наличие множественного наследования, магических методов, декораторов и возможности перегр\nНадеемся, что эта статья была полезной для вас и помогла лучше понять основы ООП в Python. Желаем вам успехов в дальнейшем изучении языка Python и создании своих программ.\nСпасибо за внимание и удачи в вашем путешествии в мир программирования!\n","date":"2023-05-01T05:00:00Z","image":"https://kotazzz.github.io/p/py09/00_placeholder_hu30ec3510ebfecb42f218b7336ef2f2e7_30114_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py09/","title":"Py09. Основы ООП в Python"},{"content":"Введение Чтобы быть в состоянии понять приемы цикла for, нам нужно сначала знать, как присваивать значения нескольким переменным одновременно. Это работает следующим образом:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a, b = 1, 2 \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; b 2 \u0026gt;\u0026gt;\u0026gt; Мы можем использовать () и [] вокруг этих значений так, как мы хотим, и все по-прежнему будет работать таким же образом. [] создает список, а () создает кортеж.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; [a, b] = (1, 2) \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; b 2 \u0026gt;\u0026gt;\u0026gt; Мы также можем иметь [] или () на одной стороне, но не на другой стороне.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; (a, b) = 1, 2 \u0026gt;\u0026gt;\u0026gt; a 1 \u0026gt;\u0026gt;\u0026gt; b 2 \u0026gt;\u0026gt;\u0026gt; Python автоматически создал кортеж.\n1 2 3 \u0026gt;\u0026gt;\u0026gt; 1, 2 (1, 2) \u0026gt;\u0026gt;\u0026gt; Если мы зацикливаемся на списке с парами значений в нем, мы могли бы сделать это:\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; items = [(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3)] \u0026gt;\u0026gt;\u0026gt; for pair in items: ... a, b = pair ... print(a, b) ... a 1 b 2 c 3 \u0026gt;\u0026gt;\u0026gt; Или мы можем сказать циклу for распаковать его для нас.\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; for a, b in items: ... print(a, b) ... a 1 b 2 c 3 \u0026gt;\u0026gt;\u0026gt; Эта функция часто используется со встроенными в Python функциями zip() и enumerate().\nzip Что приходит вам на ум, когда вы слышите слово молния? Механизм, широко используемый для связывания двух частей чего-либо, например рубашки или пиджака. Функции Python zip() делают практически то же самое, это помогает нам связать соответствующие элементы вместе.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; users = [\u0026#34;Tushar\u0026#34;, \u0026#34;Aman\u0026#34;, \u0026#34;Anurag\u0026#34;, \u0026#34;Sohit\u0026#34;] \u0026gt;\u0026gt;\u0026gt; uids = [\u0026#34;usr122\u0026#34;, \u0026#34;usr123\u0026#34;, \u0026#34;usr124\u0026#34;, \u0026#34;usr125\u0026#34;] \u0026gt;\u0026gt;\u0026gt; user_details = zip(uids, users) \u0026gt;\u0026gt;\u0026gt; print(list(user_details)) [(\u0026#39;usr122\u0026#39;, \u0026#39;Tushar\u0026#39;), (\u0026#39;usr123\u0026#39;, \u0026#39;Aman\u0026#39;), (\u0026#39;usr124\u0026#39;, \u0026#39;Anurag\u0026#39;), (\u0026#39;usr125\u0026#39;, \u0026#39;Sohit\u0026#39;)] \u0026gt;\u0026gt;\u0026gt; Обратите внимание, что print(user_details) работает не так, как ожидалось:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; print(user_details) \u0026lt;zip object at 0x0000016938E311C0\u0026gt; \u0026gt;\u0026gt;\u0026gt; Это потому, что zip() является итератором, то есть ленивым: он выдает элементы по мере необходимости, вместо того, чтобы вычислять их и сохранять в памяти все сразу, как список. Таким образом, объект zip не может показать свои элементы до того, как они будут использованы, потому что он их еще не вычислил.\n1 2 3 \u0026gt;\u0026gt;\u0026gt; users = [\u0026#34;Tushar\u0026#34;, \u0026#34;Aman\u0026#34;, \u0026#34;Anurag\u0026#34;, \u0026#34;Sohit\u0026#34;] \u0026gt;\u0026gt;\u0026gt; uids = [\u0026#34;usr122\u0026#34;, \u0026#34;usr123\u0026#34;, \u0026#34;usr124\u0026#34;, \u0026#34;usr125\u0026#34;] \u0026gt;\u0026gt;\u0026gt; user_details = zip(uids, users) Если списки имеют разную длину, некоторые элементы из конца более длинного списка будут проигнорированы.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; users = [\u0026#34;Tushar\u0026#34;, \u0026#34;Aman\u0026#34;, \u0026#34;Anurag\u0026#34;] \u0026gt;\u0026gt;\u0026gt; emails = [\u0026#34;tushar@example.com\u0026#34;, \u0026#34;aman@example.com\u0026#34;, \u0026#34;anurag@example.com\u0026#34;, \u0026#34;sohit@example.com\u0026#34;] \u0026gt;\u0026gt;\u0026gt; users_contact = zip(users, emails) \u0026gt;\u0026gt;\u0026gt; print(list(users_contact)) [(\u0026#39;Tushar\u0026#39;, \u0026#39;tushar@example.com\u0026#39;), (\u0026#39;Aman\u0026#39;, \u0026#39;aman@example.com\u0026#39;), (\u0026#39;Anurag\u0026#39;, \u0026#39;anurag@example.com\u0026#39;)] \u0026gt;\u0026gt;\u0026gt; Здесь самый короткий список - \u0026ldquo;пользователи\u0026rdquo; длиной 3, поэтому \u0026ldquo;zip (пользователи, электронные письма)\u0026rdquo; принимает только первые 3 электронных письма. Мы не рекомендуем вызывать zip() со списками разной длины, потому что игнорирование элементов обычно не то, что вы намеревались делать.\nИспользование zip в цикле for Очень часто for зацикливается на zip() и распаковывает возвращенные кортежи в цикле for. Вот почему мы представили распаковку в начале этой страницы. При использовании таким образом нет необходимости преобразовывать результат zip(...) в список.\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; roll_nums = [20, 25, 28] \u0026gt;\u0026gt;\u0026gt; students = [\u0026#34;Joe\u0026#34;, \u0026#34;Max\u0026#34;, \u0026#34;Michel\u0026#34;] \u0026gt;\u0026gt;\u0026gt; for roll_num, student in zip(roll_nums, students): ... print(f\u0026#34;Roll number of {student} is {roll_num}\u0026#34;) ... Roll number of Joe is 20 Roll number of Max is 25 Roll number of Michel is 28 \u0026gt;\u0026gt;\u0026gt; enumerate enumerate() - это удивительная встроенная функция, предлагаемая python. При использовании дает нам объединенный индекс и элемент.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; even_nums = [2, 4, 6, 8, 10, 12] \u0026gt;\u0026gt;\u0026gt; for index, item in enumerate(even_nums): ... print(f\u0026#34;Index of {item} is {index}\u0026#34;) ... Index of 2 is 0 Index of 4 is 1 Index of 6 is 2 Index of 8 is 3 Index of 10 is 4 Index of 12 is 5 \u0026gt;\u0026gt;\u0026gt; Также возможно (но более сложно) сделать это без enumerate():\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; even_nums = [2, 4, 6, 8, 10, 12] \u0026gt;\u0026gt;\u0026gt; for index in range(0, len(even_nums)): ... print(f\u0026#34;Index of {even_nums[index]} is {index}\u0026#34;) ... Index of 2 is 0 Index of 4 is 1 Index of 6 is 2 Index of 8 is 3 Index of 10 is 4 Index of 12 is 5 \u0026gt;\u0026gt;\u0026gt; Здесь:\nrange(0, len(even_nums)) дает 0,1,2,3,4,5, при этом длина списка 6 исключена. Это индексы нашего списка длиной 6. even_nums[index] выводит каждый элемент even_nums, потому что index берется из диапазона всех индексов в этом списке. Поскольку об этом сложно думать и легко ошибиться, лучше использовать enumerate().\n","date":"2023-02-28T05:00:00Z","image":"https://kotazzz.github.io/p/py08/00_placeholder_hu30ec3510ebfecb42f218b7336ef2f2e7_30114_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py08/","title":"Py08. zip() и enumerate()"},{"content":"Введение В Python список - это структура данных, которая используется для хранения набора значений. Это одна из наиболее часто используемых структур данных в Python и используется во многих различных приложениях программирования.\nСоздание списка Чтобы создать список, вы можете использовать квадратные скобки [] и разделять значения запятыми. Например:\n1 my_list = [1, 2, 3, 4, 5] Это создает список с именем my_list со значениями 1, 2, 3, 4 и 5.\nДоступ к элементам в списке Вы можете получить доступ к отдельным элементам списка, используя их индекс. В Python первый элемент в списке имеет индекс 0. Например:\n1 2 my_list = [1, 2, 3, 4, 5] print(my_list[0]) Это привело бы к выводу значения 1.\nВы также можете использовать отрицательные индексы для доступа к элементам из конца списка. Например:\n1 2 my_list = [1, 2, 3, 4, 5] print(my_list[-1]) Это привело бы к выводу значения 5.\nИзменение элементов в списке Вы можете изменять элементы в списке, присваивая новое значение определенному индексу. Например:\n1 2 3 my_list = [1, 2, 3, 4, 5] my_list[0] = 6 print(my_list) Это изменило бы первый элемент в my_list на 6.\nДобавление элементов в список Вы можете добавлять элементы в список с помощью метода append(). Например:\n1 2 3 my_list = [1, 2, 3, 4, 5] my_list.append(6) print(my_list) Это добавило бы значение 6 в конец my_list.\nВы также можете использовать метод extend() для добавления нескольких элементов в список одновременно. Например:\n1 2 3 my_list = [1, 2, 3, 4, 5] my_list.extend([6, 7, 8]) print(my_list) Это добавило бы значения 6, 7 и 8 в конец my_list.\nУдаление элементов из списка Вы можете удалить элементы из списка, используя метод remove(). Например:\n1 2 3 my_list = [1, 2, 3, 4, 5] my_list.remove(3) print(my_list) Это привело бы к удалению значения 3 из my_list. Вы также можете использовать метод pop() для удаления элемента с определенным индексом. Например:\n1 2 3 my_list = [1, 2, 3, 4, 5] my_list.pop(2) print(my_list) Это привело бы к удалению элемента с индексом 2 (третий элемент) из my_list.\nOperation Syntax Description Создание my_list = [] or my_list = list() Создает пустой список my_list = [value1, value2, ...] Создает список с начальными значениями Доступ my_list[index] Обращается к значению по указанному индексу my_list[start:end] Получает доступ к фрагменту значений от начального индекса до конечного индекса, но не включая его Модификация my_list[index] = new_value Заменяет значение по указанному индексу новым значением my_list.append(value) Добавляет новое значение в конец списка my_list.extend(iterable) Добавляет значения из iterable в конец списка my_list.insert(index, value) Вставляет новое значение по указанному индексу Удаление del my_list[index] Удаляет значение по указанному индексу my_list.remove(value) Удаляет первое вхождение указанного значения my_list.pop(index) Удаляет и возвращает значение по указанному индексу или последнее значение, если индекс не указан my_list.clear() Удаляет все значения из списка Другой len(my_list) Возвращает количество значений в списке sorted(my_list) Возвращает новый список со значениями, отсортированными в порядке возрастания reversed(my_list) Возвращает новый список со значениями в обратном порядке Более продвинутое использование Вот еще несколько полезных методов для работы со списками в Python\nappend(): добавляет элемент в конец списка 1 2 3 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] my_list.append(\u0026#39;orange\u0026#39;) print(my_list) # [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;, \u0026#39;orange\u0026#39;] insert(): вставляет элемент в определенную позицию в списке 1 2 3 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] my_list.insert(1, \u0026#39;orange\u0026#39;) print(my_list) # [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] remove(): удаляет первое вхождение указанного элемента в список 1 2 3 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] my_list.remove(\u0026#39;banana\u0026#39;) print(my_list) # [\u0026#39;apple\u0026#39;, \u0026#39;cherry\u0026#39;] pop(): удаляет элемент с указанным индексом или последний элемент, если индекс не указан, и возвращает удаленный элемент 1 2 3 4 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] removed_element = my_list.pop(1) print(my_list) # [\u0026#39;apple\u0026#39;, \u0026#39;cherry\u0026#39;] print(removed_element) # \u0026#39;banana\u0026#39; clear(): удаляет все элементы из 1 2 3 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] my_list.clear() print(my_list) # [] sort():списка, упорядочивает элементы в списке в порядке возрастания (или по убыванию, если для параметра reverse установлено значение True) 1 2 3 my_list = [3, 2, 1] my_list.sort() print(my_list) # [1, 2, 3] reverse():изменяет порядок элементов в списке на противоположный 1 2 3 my_list = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] my_list.reverse() print(my_list) # [\u0026#39;cherry\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;apple\u0026#39;] Генераторы списков Понимание списков и срезы - это две мощные функции структуры данных списков Python. Понимание списка - это краткий способ создания нового списка путем перебора существующего списка и применения некоторой операции к каждому элементу. С другой стороны, срезы позволяют вам извлечь часть списка, указав начальный и конечный индексы.\nСинтаксис: [expression for item in iterable]\nLet\u0026rsquo;s say we have a list of numbers and we want to create a new list with each number multiplied by 2: 1 2 3 4 numbers = [1, 2, 3, 4, 5] new_numbers = [num * 2 for num in numbers] print(new_numbers) # [2, 4, 6, 8, 10] We can also use an if statement to filter the items that are included in the new list: 1 2 3 numbers = [1, 2, 3, 4, 5] even_numbers = [num for num in numbers if num % 2 == 0] print(even_numbers) # [2, 4] Срезы Синтаксис: list[start_index:end_index:step]\nLet\u0026rsquo;s say we have a list of numbers and we want to extract the second through fourth elements: 1 2 3 4 numbers = [1, 2, 3, 4, 5] new_list = numbers[1:4] print(new_list) # [2, 3, 4] We can also use negative indices to start counting from the end of the list: 1 2 3 numbers = [1, 2, 3, 4, 5] new_list = numbers[-3:-1] print(new_list) # [3, 4] We can also use a step value to skip elements: 1 2 3 numbers = [1, 2, 3, 4, 5] new_list = numbers[::2] print(new_list) # [1, 3, 5] Как list comprehensions, так и slices - это мощные инструменты для работы со списками на Python, позволяющие вам с легкостью выполнять сложные операции со списками.\nЕще приемы Объединение списков: Вы можете объединить два или более списков, используя оператор +. Вот пример: 1 2 3 4 list1 = [1, 2, 3] list2 = [4, 5, 6] concatenated_list = list1 + list2 print(concatenated_list) # [1, 2, 3, 4, 5, 6] Повторение списка: Вы можете повторить список несколько раз, используя оператор *. Вот пример: 1 2 3 list1 = [1, 2, 3] repeated_list = list1 * 3 print(repeated_list) # [1, 2, 3, 1, 2, 3, 1, 2, 3] Проверка наличия элемента в списке: Вы можете проверить, присутствует ли элемент в списке, используя ключевое слово in. Вот пример: 1 2 3 list1 = [1, 2, 3] print(2 in list1) # True print(4 in list1) # False Определение длины списка: Вы можете найти количество элементов в списке с помощью функции end(). Вот пример: 1 2 list1 = [1, 2, 3] print(len(list1)) # 3 Вы также можете отсортировать список в обратном порядке, передав методу sort() параметр reverse=True: 1 2 3 list1 = [1, 2, 3] list1.sort(reverse=True) print(list1) # [3, 2, 1] ","date":"2023-02-28T04:00:00Z","image":"https://kotazzz.github.io/p/py07/00_placeholder_hu15a98e546981c427ea81cd5703498a1d_32502_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py07/","title":"Py07. Списки. Исчерпывающее руководство"},{"content":"Давненько не было ничего на сайте, да? Я решил написать пару постов, и, скорее всего опять исчезнуть куда то\u0026hellip; Вернемся к теме\nЗачем и где используется Функции являются неотъемлемой частью любого языка программирования, включая Python. Они используются для разбиения большой, сложной программы на более мелкие, более управляемые части. Функции помогают уменьшить повторяемость кода, улучшить организацию кода и модульность, а также упростить обслуживание и отладку кода.\nВот несколько причин, по которым нам нужны функции в Python:\nОрганизация кода: Функции позволяют вам разбивать ваш код на более мелкие и управляемые фрагменты. Вы можете разделить свой код на более мелкие функции, каждая из которых выполняет определенную задачу, что облегчает его чтение и понимание.\nВозможность повторного использования: функции могут быть повторно использованы в разных частях программы или в разных программах в целом. Написав функцию один раз, вы можете использовать ее несколько раз, экономя время и усилия.\nЯсность кода: Функции делают код более читаемым и понятным. Разбивая сложные задачи на более мелкие функции, вы можете писать код, который легче читать и следовать за ним.\nОбслуживание кода: Функции могут быть легко изменены или обновлены. Изменяя код в одной функции, вы можете обновить всю программу без необходимости изменять каждую строку кода.\nОтладка: Функции помогают изолировать ошибки и облегчают их выявление и исправление. Разбивая программу на более мелкие функции, вы можете определить, где произошла ошибка, и отладить эту конкретную функцию.\nТаким образом, функции являются важным инструментом в Python, который помогает программистам упорядочить свой код, сделать его более многоразовым, более удобным для чтения и понимания, а также более простым в обслуживании и отладке.\nНачало Функции - это одна из основных конструкций языка Python, которая позволяет разбивать программу на более мелкие и понятные блоки. Функции могут принимать аргументы и возвращать значения, а также быть вызваны в любой части программы. Определение функций в Python начинается с ключевого слова def, за которым следует имя функции и в скобках список аргументов функции. После этого идет двоеточие и тело функции, которое состоит из одного или нескольких операторов, которые выполняются при вызове функции. Вот пример определения функции:\n1 2 def greet(name): print(\u0026#34;Hello, \u0026#34; + name + \u0026#34;!\u0026#34;) В этом примере функция greet() принимает один аргумент name и выводит на экран приветствие с этим именем. Чтобы вызвать эту функцию, нужно просто написать ее имя и передать значение аргумента:\n1 greet(\u0026#34;Alice\u0026#34;) Это вызовет функцию greet() с аргументом \u0026quot;Alice\u0026quot;, и на экран будет выведено приветствие \u0026quot;Hello, Alice!\u0026quot;.\nreturn и параметры. Значение по умолчанию Кроме того, функции могут возвращать значения с помощью ключевого слова return. Вот еще пример:\n1 2 def square(x): return x * x Эта функция принимает один аргумент x и возвращает его квадрат. Чтобы использовать возвращаемое значение, нужно присвоить его переменной:\n1 2 result = square(3) print(result) # выводит 9 Функции в Python также могут иметь необязательные аргументы и аргументы со значениями по умолчанию. Необязательные аргументы могут быть переданы функции, но могут и не быть переданы, в этом случае используется значение по умолчанию. Вот пример функции, которая принимает два аргумента, один из которых необязательный:\n1 2 def greet(name, greeting=\u0026#34;Hello\u0026#34;): print(greeting + \u0026#34;, \u0026#34; + name + \u0026#34;!\u0026#34;) Эта функция принимает два аргумента: name - обязательный, и greeting - необязательный, со значением по умолчанию \u0026ldquo;Hello\u0026rdquo;. Если значение аргумента greeting не передано, то будет использоваться значение по умолчанию:\n1 greet(\u0026#34;Alice\u0026#34;) # выводит \u0026#34;Hello, Alice!\u0026#34; Если значение аргумента greeting передано, то будет использовано переданное значение:\n1 greet(\u0026#34;Bob\u0026#34;, \u0026#34;Hi\u0026#34;) # выводит \u0026#34;Hi, Bob!\u0026#34; *args и **kwargs в Python *args и **kwargs являются синтаксическими конструкциями в языке Python, которые позволяют передавать переменное количество аргументов в функцию. *args (или звёздочка аргументов) используется для передачи произвольного количества аргументов без ключевых слов. Аргументы передаются в виде кортежа.\nВот пример:\n1 2 3 4 5 def my_function(*args): for arg in args: print(arg) my_function(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;) В этом примере мы создали функцию my_function, которая принимает произвольное количество аргументов (*args) и выводит каждый аргумент на отдельной строке. При вызове функции мы передали три аргумента ('foo', 'bar', 'baz').\n**kwargs\n**kwargs (или двойная звёздочка аргументов) используется для передачи произвольного количества именованных аргументов. Аргументы передаются в виде словаря.\nВот пример:\n1 2 3 4 5 def my_function(`**kwargs`): for key, value in kwargs.items(): print(key, value) my_function(foo=\u0026#39;bar\u0026#39;, baz=\u0026#39;qux\u0026#39;) В этом примере мы создали функцию my_function, которая принимает произвольное количество именованных аргументов (**kwargs) и выводит каждый аргумент и его значение на отдельной строке. При вызове функции мы передали два именованных аргумента (foo='bar', baz='qux').\nКомбинирование *args и **kwargs\n*args и **kwargs можно использовать вместе, чтобы передать функции произвольное количество позиционных и именованных аргументов.\nВот пример:\n1 2 3 4 5 6 7 def my_function(*args, **kwargs): for arg in args: print(arg) for key, value in kwargs.items(): print(key, value) my_function(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, baz=\u0026#39;qux\u0026#39;, spam=\u0026#39;eggs\u0026#39;) В этом примере мы создали функцию my_function, которая принимает произвольное количество позиционных аргументов (*args) и произвольное количество именованных аргументов (**kwargs). При вызове функции мы передали два позиционных аргумента (\u0026lsquo;foo\u0026rsquo;, \u0026lsquo;bar\u0026rsquo;) и два именованных аргумента (baz=\u0026lsquo;qux\u0026rsquo;, spam=\u0026lsquo;eggs\u0026rsquo;).\nИспользование *args и **kwargs позволяет создавать более гибкие функции, которые могут принимать различное количество аргументов. Это особенно полезно, когда заранее неизвестно, сколько именно аргументов может понадобиться при вызове функции.\nОдним из примеров использования *args может быть функция, которая суммирует произвольное количество чисел:\n1 2 def my_sum(*args): return sum(args) В данном случае *args используется для того, чтобы принять произвольное количество аргументов и передать их функции в виде кортежа. Затем мы используем функцию sum(), чтобы сложить все элементы кортежа.\nАналогично, **kwargs позволяет передавать произвольное количество именованных аргументов в функцию. Они будут переданы в виде словаря:\n1 2 3 4 5 def print_kwargs(**kwargs): for key, value in kwargs.items(): print(f\u0026#34;{key} = {value}\u0026#34;) print_kwargs(name=\u0026#34;John\u0026#34;, age=30, city=\u0026#34;New York\u0026#34;) В данном примере мы используем **kwargs для передачи произвольного количества именованных аргументов в функцию. Затем мы используем цикл for для вывода каждой пары ключ-значение.\nИспользование *args и **kwargs может значительно упростить написание функций, делая их более гибкими и удобными для использования. Однако, следует учитывать, что избыточное использование этих аргументов может привести к усложнению кода и его менее явному пониманию.\n","date":"2023-02-26T04:00:00Z","image":"https://kotazzz.github.io/p/py06/00_placeholder_hu783df2b7b01877a9fdea2cc22a61e847_106265_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/py06/","title":"Py06. Функции"},{"content":" Сюжет 🖌 Идея Главный герой терпит крушение и попадает на остров. Он натыкается на одно из поселений а позже обнаруживает второе. В итоге герой выясняет, что эти поселения когда то имели тесный контакт, но сейчас они враждуют и грядет война, в которой будет убито много невинных. Как герой выберется с острова и разрулит ли он эту ситуацию - зависит от действий\n👥 Известные персонажи и места Герой Имя, возраст, пр. Описание Мотивация 👤 Главный герой 1 Саймон Главный герой игры. Попадает на остров, так как его корабль был разрушен Хочет выжить и вернуться домой, построив новый корабль 👤 Главный герой 2 Даниель Так же главный герой игры. Является играбельным Хочет покинуть рабство 👤 Главный герой 3 Нет информации 🏠 Поселение 1 - Нет никакой информации Хотят развязать войну с поселением 2 🏠 Поселение 2 - Нет никакой информации Хотят развязать войну с поселением 1 👥 Аборигены - Населяют поселения. Говорят на ломанном языке, так как были обучены иностранцами, которые на данный момент находятся в плену Мотивация привязана к поселению 👥 Пленные - Иностранцы. Рабы, работающие на поселения. Обучили языку. Лор неизвестен ⚠ Хотят устроить бунт 🗺 Карта сюжета 🏹 Выборы и ветвления Местоположение Выбор Результат Глава 1 Для того, что бы выжить, надо быстро прожимать QWE При достаточных усилиях герой выживет. Иначе - конец игры Глава 1 Персонаж находит рыбу, кроме костей и хлама. Оставить, отпустить, забрать Отпустить = Доброта+1; Оставить = Доброта-1; Взять = Доброта-1 Глава 1 Персонажа находят аборигены. Сдаться, дать рыбу, напасть Сдаться=Мнение+0;Дать рыбу=Мнение+1;Напасть=Мнение-1 Глава 1 Персонаж напал на аборигенов. QWE При достаточных усилиях герой выживет. Иначе - конец игры 📚 Черновик Глава 1 Саймон вел свой корабль направляясь уже домой после небольшого путешествия со своей командой. Но один из экипажа допустил ошибку и указал неверный путь, тем самым подписав смертный приговор всему составу корабля. Судно попадает в сильный шторм, от чего корабль буквально расстворяется в воде, куда делись остальные члены экипажа - неизвестно. Наш капитан Саймон просыпается на небольшом деревянном корабля, который способен выдержать человека. Кроме него ничего вокруг нет, но если посмотреть в сторону запада - можно увидеть остров. Импровизированный плот выглядит ненадежно - скоро он развалится. Надо как можно скорее догребсти до острова ⚠️ Получение управления: для того что бы плыть дальше, надо нажимать QWE, как можно быстрее ❌ Если не постараться, Саймон погибнет и игра окончится ✅ Игра может быть продолжена, если все пройдет успешно Остров кажется достаточно большим. Тут есть огромный пляж, а так же достаточно густой лес, можно сказать, что это даже джунги. Герой может осмотреться ⚠️ Герой может найти кости. Кости не дают никакой дополнительной информации. Саймон считает, что это дикие животные ⚠️ Герой может поймать рыбу, которая запуталась в сети. Сеть зацепилась за обломок плота, который остался от прибытия героя 1 Отпустить (🟢Доброта) 2 Оставить, как есть (🔴Доброта) 3 Взять с собой (🔴Доброта) (🔹Рыба x1) Герой дальше использует остров, находит пару камней и больше ничего Внезапно, со стороны тех самых джунглей, выходят странные дикие люди. Они немного говорят на родном языке, с небольшим акцентом и парой ошибок. Два из них говорили с героем А1 - Кто ты есть? С - Я Саймон, мой корабль потерпел крушение и я очутился здесь А2 - Мы не доверять тебе! Ты будешь отдан нашему вождю! А1 - Да! Он решит, что сделать с Саймон! С - Подож- А1 - Мы тебя свяжем, что бы ты не навредил нам! ⚠️ У героя есть возможность предпринять действие 1 Сдаться (🟡Мнение) 2 🔹 Предложить рыбу(🟢Мнение) 3 Напасть(🔴Мнение) ⚠️ При нападении надо выжить. QWE-механика для драки. ❌ В случае неудачи - конец игры, героя убьют из-за достущенной боевой ошибки ✅ Саймона одолеют, но не будут убивать героя Саймон был связан и взят аборигенами underlined text \u0026ldquo;abc\u0026rdquo;: abc Глава 1.2 А1 - Даниель! Приказ встать! Ты должен работать Даниель встает от резкого крика в строну уже открытой камеры где-то в пещере Д - Хорошо ⚠️Если Саймон жив, то будет доступны дополнительные детали А1 - Саймон, подъем С - Что случилось\u0026hellip; Где я? А1 - В пещере Звук удара палкой С - Ай! Что ты делаешь! А1 Разбирай завал. Даниель. Помоги Саймон Д - Привет\u0026hellip; Я Даниель. Ты тут новенький? С - А я Саймон. Приятно познакомиться. Я сюда попал после крушения корабля. Д - Теперь ты в рабстве до конца дней\u0026hellip; Если только не пройизойдет чудо С - Оу\u0026hellip; Но я не хочу здесь оставаться! Я надеюсь, что ты поможешь мне выбраться! Д - Но эти поселенцы слишком сильные С - Мы что нибудь придумаем. Ладно, давай попробуем выполнить задачу. Где завал? Д - В той стороне, пойдем Теперь Саймон и Даниель разбирают завал вместе с другими рабами. Вся стража разошлась со временем из-за ненадобности наблюдать за работой рабов, которые точно не сбегут. Одного из рабов резко заваливает камнями, еще один вот-вот упадет прямо на него и окажется фатальным. ⚠️ Саймон: Попытаться ли помочь рабу? 1 Саймон побежит спасать раба (🔹Спасение) 2 Никаких действий не будет предпринято ⚠️ Даниель: Попытаться ли помочь рабу? 1 Даниель побежит спасать раба 2 Никаких действий не будет предпринято 3 🔹 Остановить Саймона ⚠️ Один человек, спасающий раба: требуется приложить усилия, что бы спасти раба. QWE-техника ✅ Раб был спасен, все целы ❌ Раб был убит ⚠️ Два человека: усилий не требуется. Раб спасен ⚠️ Даниель остановил Саймона. Раб погиб. (🟢Доверие) :orange_book: Переменные\nПеременная Описание Мнение Общие отношения между аборигенами и рабами Доброта Уровень доброты Саймона Доверие Отношение Саймона и Даниеля ","date":"2022-07-24T04:00:00Z","permalink":"https://kotazzz.github.io/p/yarik/","title":"Сюжет и планы для игры"},{"content":"Я расскажу о циклах for и while, операторах break и continue, а также о слове else, которое, будучи употребленное с циклом, может сделать программный код несколько более понятным.\nЦикл while While - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; i = 5 \u0026gt;\u0026gt;\u0026gt; while i \u0026lt; 15: ... print(i) ... i = i + 2 ... 5 7 9 11 13 Цикл for Общее понятие Цикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (например строке или списку), и во время каждого прохода выполняет тело цикла. Цикл for используется в том случае, когда необходимо выполнить некоторую часть кода до тех пор, пока не будет выполнено заданное условие. Цикл for также называют циклом c предусловием. Лучше использовать цикл for, если количество итераций известно заранее.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheelllloo wwoorrlldd range() Мы используем встроенную функцию Python range. Функция range создаст список длинной в «n» элементов. В Python версии 2.Х существует другая функция под названием xrange, которая является генератором чисел и не такая ресурсоемкая, как range. Ранее разработчики сменили xrange на range в Python 3. Вот пример:\n1 print(range(5)) # ответ: range(0, 5) Как вы видите, функция range взяла целое число и вернула объект range. Функция range также принимает начальное значение, конечное значение и значение шага. Вот еще два примера:\n1 2 3 4 5 a = range(5, 10) print(a) # range(5, 10) b = list(range(1, 10, 2)) print(b) # [1, 3, 5, 7, 9] В пером примере показано, что вы можете передать начальное и конечное значение, и функция range вернет числа, начиная с начального значения вплоть до (но не включая) последнее значение. Например, при запросе 5-10 мы получим 5-9. Во втором примере видно, как использовать функцию списка (list) для того, чтобы функция range вернула каждый второй элемент, между 1 и 10. Так что она начинает с 1, пропускает 2 и так далее. Теперь вы, наверное, гадаете, что же именно она будет делать с циклами? Что-ж, есть один простой способ показать, как работает цикл с использованием функции range! Давайте взглянем:\n1 2 for number in range(5): print(number) Что здесь произошло? Давайте почитаем слева на право, чтобы понять это. Для каждого числа в диапазоне 5 мы вводим число. Мы знаем, что если мы вызываем range со значением 5, мы получим список из 5 элементов. Так что каждый раз, проходя через цикл, она выводит каждый из элементов. Цикл for, показанный выше, может быть эквивалентом следующего:\n1 2 for number in [0, 1, 2, 3, 4]: print(number) Мы попробуем применить цикл в функции range, но нам нужно вывести только целые числа. Чтобы сделать это, нам нужно использовать условный оператор вместо параметра шага range. Это можно сделать следующим образом:\n1 2 3 4 5 6 7 8 for number in range(10): if number % 2 == 0: print(number) # 0 # 2 # 4 # 6 # 8 Вы наверное гадаете, что вообще здесь происходит? Что еще за знак процента? В Python, % называется оператором модуля. Когда вы используете оператор модуля, он возвращает остаток. Когда вы делите целое число на два, вы получаете число без остатка, так что мы выводим эти числа. Вам, возможно, не захочется использовать оператор модуля часто в будущем, но в моей работе он нередко помогает. Теперь мы можем взглянуть на цикл while.\nСловари Функция range лишь делает результат несколько меньшим. Цикл for может обходить любой итератор Python. Мы уже видели, как именно он может работать со списком. Давайте взглянем, может ли он выполнять итерацию со словарем.\n1 2 3 4 a_dict = {\u0026#34;one\u0026#34;:1, \u0026#34;two\u0026#34;:2, \u0026#34;three\u0026#34;:3} for key in a_dict: print(key) Когда вы используете for в словаре, вы увидите, что он автоматически перебирает ключи. Вам не нужно указывать ключ for в a_dict.keys() (впрочем, это также работает). Python делает только нужные нам вещи. Вы возможно думаете, почему ключи выводятся в другом порядке, отличном от того, какой был указан в словаре? Как мы знаем из соответствующей статьи, словари не упорядочены, так что мы можем выполнять итерацию над ними, при этом ключи могут быть в любом порядке. Теперь, зная, что ключи могут быть отсортированы, вы можете отсортировать их до итерации. Давайте немного изменим словарь, чтобы увидеть, как это работает.\n1 2 3 4 5 6 7 8 9 a_dict = {1:\u0026#34;one\u0026#34;, 2:\u0026#34;two\u0026#34;, 3:\u0026#34;three\u0026#34;} keys = a_dict.keys() keys = sorted(keys) for key in keys: print(key) # 1 # 2 # 3 Давайте остановимся и разберемся с тем, что делает этот код. Во-первых, мы создали словарь, в котором ключи выступают в качестве целых чисел, вместо строк. Далее, мы извлекли ключи из словаря. Каждый раз, когда вы взываете метод keys(), он возвращает неупорядоченный список ключей. Если вы выведите их, и увидите, что они расположен в порядке по возрастанию, то это просто случайность. Теперь у нас есть доступ к ключам словаря, которые хранятся в переменной, под названием keys. Мы сортируем наш список, после чего используем цикл for в нем. Теперь мы готовы к тому, чтобы сделать все немного интереснее.\nОператор continue Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;o\u0026#39;: ... continue ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheellll wwrrlldd Оператор break Оператор break досрочно прерывает цикл.\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;o\u0026#39;: ... break ... print(i * 2, end=\u0026#39;\u0026#39;) ... hheellll Волшебное слово else Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же \u0026ldquo;естественным\u0026rdquo; образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; for i in \u0026#39;hello world\u0026#39;: ... if i == \u0026#39;a\u0026#39;: ... break ... else: ... print(\u0026#39;Буквы a в строке нет\u0026#39;) ... Буквы a в строке нет ","date":"2022-07-23T04:00:00Z","image":"https://kotazzz.github.io/p/py05/00_placeholder_hu7c6670ce376b478e0562503f0e66f11f_12047_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/py05/","title":"Py05. Циклы Python"},{"content":"Условная инструкция if-elif-else (её ещё иногда называют оператором ветвления) - основной инструмент выбора в Python. Проще говоря, она выбирает, какое действие следует выполнить, в зависимости от значения переменных в момент проверки условия.\nСинтаксис if Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:\n1 2 3 4 5 6 if test1: state1 elif test2: state2 else: state3 Простой пример (напечатает \u0026rsquo;true\u0026rsquo;, так как 1 - истина):\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; if 1: ... print(\u0026#39;true\u0026#39;) ... else: ... print(\u0026#39;false\u0026#39;) ... true Чуть более сложный пример (его результат будет зависеть от того, что ввёл пользователь):\n1 2 3 4 5 6 7 a = int(input()) if a \u0026lt; -5: print(\u0026#39;Low\u0026#39;) elif -5 \u0026lt;= a \u0026lt;= 5: print(\u0026#39;Mid\u0026#39;) else: print(\u0026#39;High\u0026#39;) Проверка истинности в Python Любое число, не равное 0, или непустой объект - истина. Числа, равные 0, пустые объекты и значение None - ложь Операции сравнения применяются к структурам данных рекурсивно Операции сравнения возвращают True или False Логические операторы and и or возвращают истинный или ложный объект-операнд Логические операторы X and Y: Истина, если оба значения X и Y истинны. X or Y: Истина, если хотя бы одно из значений X или Y истинно. not X: Истина, если X ложно. X is Y: Истина, если объект X является объектом Y. X is not Y: Истина, если объект X не является объектом Y. X == Y: Истина, если значения X и Y равны. X != Y: Истина, если значения X и Y не равны. X \u0026gt; Y: Истина, если значение X больше значения Y. X \u0026gt;= Y: Истина, если значение X больше или равно значению Y. X \u0026lt; Y: Истина, если значение X меньше значения Y. X \u0026lt;= Y: Истина, если значение X меньше или равно значению Y. Трехместное выражение if/else Следующая инструкция:\n1 2 3 4 if X: A = Y else: A = Z довольно короткая, но, тем не менее, занимает целых 4 строки. Специально для таких случаев и было придумано выражение if/else:\n1 A = Y if X else Z В данной инструкции интерпретатор выполнит выражение Y, если X истинно, в противном случае выполнится выражение Z.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; A = \u0026#39;t\u0026#39; if \u0026#39;spam\u0026#39; else \u0026#39;f\u0026#39; \u0026gt;\u0026gt;\u0026gt; A \u0026#39;t\u0026#39; ","date":"2022-07-23T03:00:00Z","image":"https://kotazzz.github.io/p/py04/00_placeholder_hu26b6f633f6e7d2bd1cb701f508024f99_224752_120x120_fill_box_smart1_3.png","permalink":"https://kotazzz.github.io/p/py04/","title":"Py04. Инструкция if"},{"content":"Не работает функция input. Пишет SyntaxError Пример кода:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a = input() hello world File \u0026#34;\u0026lt;string\u0026gt;\u0026#34;, line 1 hello world ^ SyntaxError: unexpected EOF while parsing Причина: Вы запустили Python 2.\nРешение: Установить Python 3.\nГде-то увидел простую программу, а она не работает Пример кода:\n1 2 3 4 5 6 7 8 name = raw_input() print name Ошибка: File \u0026#34;a.py\u0026#34;, line 3 print name ^ SyntaxError: invalid syntax Причина: Вам подсунули программу на Python 2.\nРешение: Прочитать об отличиях Python 2 от Python 3. Переписать её на Python 3. Например, данная программа на Python 3 будет выглядеть так:\n1 2 name = input() print(name) TypeError: Can't convert 'int' object to str implicitly Пример кода:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a = input() + 5 8 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: Can\u0026#39;t convert \u0026#39;int\u0026#39; object to str implicitly Причина: Нельзя складывать строку с числом.\nРешение: Привести строку к числу с помощью функции int(). Кстати, заметьте, что функция input() всегда возвращает строку!\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = int(input()) + 5 8 \u0026gt;\u0026gt;\u0026gt; a 13 SyntaxError: invalid syntax Пример кода:\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; if a == 5 ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 3 if a == 5 ^ SyntaxError: invalid syntax Причина: Забыто двоеточие.\nРешение:\n1 2 3 a = 5 if a == 5: print(\u0026#39;Ура!\u0026#39;) SyntaxError: invalid syntax 2 Пример кода:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a = 5 \u0026gt;\u0026gt;\u0026gt; if a = 5: ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 3 if a = 5 ^ SyntaxError: invalid syntax Причина: Забыто равно.\nРешение:\n1 2 3 a = 5 if a == 5: print(\u0026#39;Ура!\u0026#39;) NameError: name 'a' is not defined Пример кода:\n1 print(a) Причина: Переменная \u0026ldquo;a\u0026rdquo; не существует. Возможно, вы опечатались в названии или забыли инициализировать её.\nРешение: Исправить опечатку.\n1 2 a = 10 print(a) IndentationError: expected an indented block Пример кода:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; 0: ... print(a) Причина: Нужен отступ.\nРешение:\n1 2 3 a = 10 if a \u0026gt; 0: print(a) TabError: inconsistent use of tabs and spaces in indentation Пример кода:\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a = 10 \u0026gt;\u0026gt;\u0026gt; if a \u0026gt; 0: ... print(a) ... print(\u0026#39;Ура!\u0026#39;) File \u0026#34;a.py\u0026#34;, line 5 print(\u0026#39;Ура!\u0026#39;) ^ TabError: inconsistent use of tabs and spaces in indentation Причина: Смешение пробелов и табуляции в отступах.\nРешение: Исправить отступы.\n1 2 3 4 a = 10 if a \u0026gt; 0: print(a) print(\u0026#39;Ура!\u0026#39;) UnboundLocalError: local variable 'a' referenced before assignment Пример кода:\n1 2 3 4 5 6 def f(): a += 1 print(a) a = 10 f() 1 2 3 4 5 6 Traceback (most recent call last): File \u0026#34;a.py\u0026#34;, line 7, in \u0026lt;module\u0026gt; f() File \u0026#34;a.py\u0026#34;, line 3, in f a += 1 UnboundLocalError: local variable \u0026#39;a\u0026#39; referenced before assignment Причина: Попытка обратиться к локальной переменной, которая ещё не создана.\nРешение:\n1 2 3 4 5 6 7 def f(): global a a += 1 print(a) a = 10 f() Программа выполнилась, но в файл ничего не записалось / записалось не всё Пример кода:\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;bla\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; Причина: Не закрыт файл, часть данных могла остаться в буфере.\nРешение:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; f = open(\u0026#39;output.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) \u0026gt;\u0026gt;\u0026gt; f.write(\u0026#39;bla\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; f.close() \u0026gt;\u0026gt;\u0026gt; ","date":"2022-07-23T02:00:00Z","image":"https://kotazzz.github.io/p/py03/00_placeholder_hud01c0bb4b476d9d6603890be4431c360_205752_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py03/","title":"Py03. Почему моя программа не работает? (FAQ)"},{"content":"Начало работы с языком Сейчас большинство операций с кодом будет проводиться внутри файла. Если вы хотите повторить то, что происходит тут, создайте файл и пишите код туда. О том, как запустить файл, можно узнать в прошлом уроке.\nВывод Вывод на экран Выводимые данные можно перечислять через запятую\n1 2 3 4 5 print(\u0026#34;Hello, world!\u0026#34;) # Hello, world! print(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;) # A B print(1, 2, 3) # 1 2 3 print(True, False, None) # True False None print(\u0026#34;a\u0026#34;, 1, True) # a 1 True Так же можно проводить простые вычисления\n1 2 3 print(1 + 2) # 3 print(1 + 2, 3 + 4) # 3 7 print(1 - 3) # -2 sep = sep — это может быть строка, которую необходимо вставлять между значениями, по умолчанию — пробел.\nВставим список слов в print и разделим их с помощью символа новой строки. Еще раз: по умолчанию разделитель добавляет пробел между каждым словом.\n1 2 print(\u0026#39;туториал\u0026#39;, \u0026#39;по\u0026#39;, \u0026#39;функции\u0026#39;, \u0026#39;print()\u0026#39;) # туториал по функции print() \\n перенесет каждое слово на новую строку\n1 2 3 4 5 print(\u0026#39;туториал\u0026#39;, \u0026#39;по\u0026#39;, \u0026#39;функции\u0026#39;, \u0026#39;print()\u0026#39;, sep=\u0026#39;\\n\u0026#39;) # туториал # по # функции # print() end = end — это строка, которая добавляется после последнего значения. По умолчанию — это перенос на новую строку (\\n). С помощью аргумента end программист может самостоятельно определить окончание выражения print.\nПредположим, есть две строки, а задача состоит в том, чтобы объединить их, оставив пробел. Для этого нужно в первой функции print указать первую строку, str1 и аргумент end с кавычками. В таком случае на экран выведутся две строки с пробелом между ними.\n1 2 3 4 5 6 7 8 9 10 str1 = \u0026#39;туториал по\u0026#39; str2 = \u0026#39;функции print()\u0026#39; print(str1) print(str2) # туториал по # функции print() print(str1, end=\u0026#39; \u0026#39;) print(str2) # туториал по функции print() Возьмем другой пример, где есть функция, которая должна выводить значения списка на одной строке. Этого можно добиться с помощью такого значения аргумента end:\n1 2 3 4 5 6 7 def value(items): for item in items: print(item, end=\u0026#39; \u0026#39;) value([1,2,3,4]) # 1 2 3 4 Переменные Переменные содержат данные. Благодаря этому к ним можно обращаться, заново использовать, вызывать, назначать и так далее. Понимать переменные важно для работы с любой логикой в программировании. Это то, что знает любой программист вне зависимости от языка программирования, и поэтому это так важно для начинающих. Простейшее определение переменной — это именованный контейнер для данных, к которым нужно обращаться в программе. Есть 2 основные причины для этого:\nЗачастую данные — это больше чем 2 символа. Обычно к ним нужно обращаться по несколько раз. Где используется? Сложно представить программирование без переменных. Это как обращаться к людям, не используя их имена и фамилии. Можно только представить, насколько это было бы неудобно. В программировании переменные используются для определения и обращения к данным разных размеров, типов и форм. Правила использования При присвоении значения переменная всегда находится слева, а данные — справа. Имя переменной может начинаться с символа или нижнего подчеркивания (_), но не с числа. Для вывода значения переменной с помощью функции print нужно передавать ее без кавычек. Переменные создаются по принципу: \u0026lt;имя\u0026gt; = \u0026lt;значение\u0026gt;. Не смотря на поддержку русских названий переменных, рекомендуется использовать латинские названия. Есть негласные правила для названий. Для переменных, объектов, функций, иногда констант это snake_case (маленькми буквами, слова отделяются нижним подчеркиванием), а для классов - CamelCase (большими буквами, первая буква большая). Для констант применяется так же UPPER_CASE (большими буквами, через нижнее подчеркивание). Так же рекомендуется избегать транслита. Лучше назвать переменную variable, а не peremennaya. Частые ошибки Начинать имя переменной с цифры. Использовать символы (кроме нижнего подчеркивания) в имени переменной. Использовать в переменной пробелы. Примеры использования переменных Предположим, что есть большое число: 149597970. Оно обозначает расстояние между Солнцем и Землей в километрах. Предположим, что к этому значению нужно обратиться для выполнения вычислений. Вместо того, чтобы каждый раз вводить его, можно просто использовать переменную. Вот так:\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; sun_to_earth = 149597970 \u0026gt;\u0026gt;\u0026gt; sun_to_earth = sun_to_earth + 1 \u0026gt;\u0026gt;\u0026gt; print(sun_to_earth) 149597971 Разберем код примера: Сначала создается переменная sun_to_earth, и ей присваивается значение 149597970. Переменной sun_to_earth присваивается новое значение — 149597971.\nПеременные - это место в памяти, куда можно сохранить данные.\n1 2 3 4 5 a = 1 + 2 # 3 b = \u0026#34;123\u0026#34; c = True d = None print(a, b, c, d) # 1 123 True None Парочка интересных моментов языка\nПри выводе на экран значение переменной никуда не девается и мы можем вывести значение сколько раз угодно print все еще может выводить значения одновременно с переменным В отличии от многих других языков в python отсутствует типизация и ему абсолютно параллельно, что мы будем присваивать переменной - новое число или новую строку. Делать мы можем это сколько раз угодно. При новом присваивании питон автоматически меняет тип переменной Мы можем указывать эту переменную в вычислениях, про операции с переменными и константами мы поговорим отдельно Мы можем резко поменять то, что хранится в переменной - было число, стало строка Ввод 1 2 name = input(\u0026#34;Введите ваше имя: \u0026#34;) # Вводим имя print(\u0026#34;Привет, \u0026#34;, name) # Выводим приветствие input - это функция, которая требует 1 аргумент, это строка, которая будет выведена перед вводом. Возвращает введенную строку. print - к слову, тоже функция, но на вход принимает любое количество аргументов, которые будут распечатаны. Возвращает None.\nТипы данных Основных типо данных несколько. Сейчас говорится не о всех\nТип Описание Пример int Целое число 123 float Число с плавающей точкой 1.23 str Строка \u0026ldquo;Hello, world!\u0026rdquo; bool Логическое значение True, False complex Комплексное число 1 + 2j none Значение не определено None list Список [1, 2, 3] set Множество {1, 2, 3} tuple Кортеж (1, 2, 3) dict Словарь {1: \u0026ldquo;one\u0026rdquo;, 2: \u0026ldquo;two\u0026rdquo;} Строки Про кавычки \u0026quot;1\u0026quot; и '1' - эти 2 записи - одно и тоже \u0026quot;строка в \u0026quot;кавычках\u0026quot;\u0026quot; - такая запись вызовет ошибки, изза того, что питон запутается в одинаковых кавычках 'тут \u0026quot;кавычки\u0026quot;' - тут питон не запутался в кавычках, так как они разные \u0026quot;тут 'кавычки'\u0026quot; - кавычки можно комбинировать, все четыре типа кавычек (', \u0026quot;, \u0026quot;\u0026quot;\u0026quot;, ''') можно комбинировать, главное, что бы строка начиналась и заканчивалась одним типом кавычек 'текст \\'в\\' кавычках' - тут с помощью \\ кавычки были экранизированы, и теперь питон не запутается \u0026quot; 123 \\\u0026quot; 123\u0026quot; - тот же самый случай с другими кавычками\nПро \\ \\ внутри строки отвечает за вывод некоторых символов и экранизацию, пока что просто помните, что: \\\u0026quot; \\' - \u0026ldquo;защищеные\u0026rdquo; от поломки кода кавычки, которые можно использовать в тексте \\\\ - вывод \\ без каких либо экранизаций и прочего \\n \\t - новая строка и табуляция (как при нажатии на Tab)\nПро мультистроки Иногда бывает очень много текста, который содержит переносы строк (\\n), тогда можно использовать мультистроки, который можно растягивать на любое количество строк кода, в то время как обычные - нельзя:\n1 2 3 4 5 6 7 8 9 10 11 print(\u0026#34;\u0026#34;\u0026#34; Этот текст содержит множество переносов строк и огромное количество текста... \u0026#34;\u0026#34;\u0026#34;) # Убрать первый перенос строки print(\u0026#34;\u0026#34;\u0026#34;\\ 123 123 \u0026#34;\u0026#34;\u0026#34;) ''' и \u0026quot;\u0026quot;\u0026quot; - опять же одно и тоже Экранизировать ' внутри ''' или \u0026quot; внутри \u0026quot;\u0026quot;\u0026quot; - не надо, питон запутается лишь если вы напечатаете сразу 3 кавычки подряд внутри мультстроки Если вы сразу после первой тройной кавычки ставите перенос строки - то при выводе на экран у вас выведется одна пустая строка. Что бы этого избежать - поставьте \\ который уберет эту лишнюю пустую строку. Так же можно писать любой текст сразу после тройных кавычек вместо \\ Целые числа (int), комплексные (complex) и вещественные числа (float) Целые числа (int) Числа в Python 3 ничем не отличаются от обычных чисел. Они поддерживают набор самых обычных математических операций:\nОперация Описание x + y Сложение x - y Вычитание x * y Умножение x / y Деление x // y Получение целой части от деления x % y Остаток от деления -x Смена знака числа abs(x) Модуль числа divmod(x, y) Пара (x // y, x % y) x ** y Возведение в степень pow(x, y[, z]) xy по модулю (если модуль задан) Длинная арфиметика Также нужно отметить, что целые числа в python 3, в отличие от многих других языков, поддерживают длинную арифметику (однако, это требует больше памяти).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026gt;\u0026gt;\u0026gt; 255 + 34 289 \u0026gt;\u0026gt;\u0026gt; 5 * 2 10 \u0026gt;\u0026gt;\u0026gt; 20 / 3 6.666666666666667 \u0026gt;\u0026gt;\u0026gt; 20 // 3 6 \u0026gt;\u0026gt;\u0026gt; 20 % 3 2 \u0026gt;\u0026gt;\u0026gt; 3 ** 4 81 \u0026gt;\u0026gt;\u0026gt; pow(3, 4) 81 \u0026gt;\u0026gt;\u0026gt; pow(3, 4, 27) 0 \u0026gt;\u0026gt;\u0026gt; 3 ** 150 369988485035126972924700782451696644186473100389722973815184405301748249 Побитовые операции Над целыми числами также можно производить битовые операции\nОперация Описание x | y Побитовое или x ^ y Побитовое исключающее или x \u0026amp; y Побитовое и x \u0026laquo; n Битовый сдвиг влево x \u0026raquo; y Битовый сдвиг вправо ~x Инверсия битов Дополнительные методы int.bit_length() - количество бит, необходимых для представления числа в двоичном виде, без учёта знака и лидирующих нулей.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; n = -37 \u0026gt;\u0026gt;\u0026gt; bin(n) \u0026#39;-0b100101\u0026#39; \u0026gt;\u0026gt;\u0026gt; n.bit_length() 6 int.to_bytes(length, byteorder, *, signed=False) - возвращает строку байтов, представляющих это число.\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; (1024).to_bytes(2, byteorder=\u0026#39;big\u0026#39;) b\u0026#39;\\x04\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; (1024).to_bytes(10, byteorder=\u0026#39;big\u0026#39;) b\u0026#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; (-1024).to_bytes(10, byteorder=\u0026#39;big\u0026#39;, signed=True) b\u0026#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xfc\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; x = 1000 \u0026gt;\u0026gt;\u0026gt; x.to_bytes((x.bit_length() // 8) + 1, byteorder=\u0026#39;little\u0026#39;) b\u0026#39;\\xe8\\x03\u0026#39; classmethod int.from_bytes(bytes, byteorder, *, signed=False) - возвращает число из данной строки байтов. 1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00\\x10\u0026#39;, byteorder=\u0026#39;big\u0026#39;) 16 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\x00\\x10\u0026#39;, byteorder=\u0026#39;little\u0026#39;) 4096 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\xfc\\x00\u0026#39;, byteorder=\u0026#39;big\u0026#39;, signed=True) -1024 \u0026gt;\u0026gt;\u0026gt; int.from_bytes(b\u0026#39;\\xfc\\x00\u0026#39;, byteorder=\u0026#39;big\u0026#39;, signed=False) 64512 \u0026gt;\u0026gt;\u0026gt; int.from_bytes([255, 0, 0], byteorder=\u0026#39;big\u0026#39;) 16711680 Системы счисления Те, у кого в школе была информатика, знают, что числа могут быть представлены не только в десятичной системе счисления. К примеру, в компьютере используется двоичный код, и, к примеру, число 19 в двоичной системе счисления будет выглядеть как 10011. Также иногда нужно переводить числа из одной системы счисления в другую. Python для этого предоставляет несколько функций:\nint([object], [основание системы счисления]) - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно. bin(x) - преобразование целого числа в двоичную строку. hex(х) - преобразование целого числа в шестнадцатеричную строку. oct(х) - преобразование целого числа в восьмеричную строку. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt;\u0026gt;\u0026gt; a = int(\u0026#39;19\u0026#39;) # Переводим строку в число \u0026gt;\u0026gt;\u0026gt; b = int(\u0026#39;19.5\u0026#39;) # Строка не является целым числом Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in ValueError: invalid literal for int() with base 10: \u0026#39;19.5\u0026#39; \u0026gt;\u0026gt;\u0026gt; c = int(19.5) # Применённая к числу с плавающей точкой, отсекает дробную часть \u0026gt;\u0026gt;\u0026gt; print(a, c) 19 19 \u0026gt;\u0026gt;\u0026gt; bin(19) \u0026#39;0b10011\u0026#39; \u0026gt;\u0026gt;\u0026gt; oct(19) \u0026#39;0o23\u0026#39; \u0026gt;\u0026gt;\u0026gt; hex(19) \u0026#39;0x13\u0026#39; \u0026gt;\u0026gt;\u0026gt; 0b10011 # Так тоже можно записывать числовые константы 19 \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;10011\u0026#39;, 2) 19 \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0b10011\u0026#39;, 2) 19 Вещественные числа (float) Вещественные числа поддерживают те же операции, что и целые. Однако (из-за представления чисел в компьютере) вещественные числа неточны, и это может привести к ошибкам:\n1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 0.9999999999999999 Для высокой точности используют другие объекты (например Decimal и Fraction)).\nТакже вещественные числа не поддерживают длинную арифметику:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; a = 3 ** 1000 \u0026gt;\u0026gt;\u0026gt; a + 0.1 Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in OverflowError: int too large to convert to float Простенькие примеры работы с числами:\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; c = 150 \u0026gt;\u0026gt;\u0026gt; d = 12.9 \u0026gt;\u0026gt;\u0026gt; c + d 162.9 \u0026gt;\u0026gt;\u0026gt; p = abs(d - c) # Модуль числа \u0026gt;\u0026gt;\u0026gt; print(p) 137.1 \u0026gt;\u0026gt;\u0026gt; round(p) # Округление 137 Дополнительные методы\nfloat.as_integer_ratio() - пара целых чисел, чьё отношение равно этому числу.\nfloat.is_integer() - является ли значение целым числом.\nfloat.hex() - переводит float в hex (шестнадцатеричную систему счисления).\nclassmethod float.fromhex(s) - float из шестнадцатеричной строки.\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; (10.5).hex() \u0026#39;0x1.5000000000000p+3\u0026#39; \u0026gt;\u0026gt;\u0026gt; float.fromhex(\u0026#39;0x1.5000000000000p+3\u0026#39;) 10.5 Помимо стандартных выражений для работы с числами (а в Python их не так уж и много), в составе Python есть несколько полезных модулей.\nМодуль math предоставляет более сложные математические функции.\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi 3.141592653589793 \u0026gt;\u0026gt;\u0026gt; math.sqrt(85) 9.219544457292887 Модуль random реализует генератор случайных чисел и функции случайного выбора.\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() 0.15651968855132303 Комплексные числа (complex) В Python встроены также и комплексные числа:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026gt;\u0026gt;\u0026gt; x = complex(1, 2) \u0026gt;\u0026gt;\u0026gt; print(x) (1+2j) \u0026gt;\u0026gt;\u0026gt; y = complex(3, 4) \u0026gt;\u0026gt;\u0026gt; print(y) (3+4j) \u0026gt;\u0026gt;\u0026gt; z = x + y \u0026gt;\u0026gt;\u0026gt; print(x) (1+2j) \u0026gt;\u0026gt;\u0026gt; print(z) (4+6j) \u0026gt;\u0026gt;\u0026gt; z = x * y \u0026gt;\u0026gt;\u0026gt; print(z) (-5+10j) \u0026gt;\u0026gt;\u0026gt; z = x / y \u0026gt;\u0026gt;\u0026gt; print(z) (0.44+0.08j) \u0026gt;\u0026gt;\u0026gt; print(x.conjugate()) # Сопряжённое число (1-2j) \u0026gt;\u0026gt;\u0026gt; print(x.imag) # Мнимая часть 2.0 \u0026gt;\u0026gt;\u0026gt; print(x.real) # Действительная часть 1.0 \u0026gt;\u0026gt;\u0026gt; print(x \u0026gt; y) # Комплексные числа нельзя сравнить Traceback (most recent call last): File \u0026#34;\u0026#34;, line 1, in TypeError: unorderable types: complex() \u0026gt; complex() \u0026gt;\u0026gt;\u0026gt; print(x == y) # Но можно проверить на равенство False \u0026gt;\u0026gt;\u0026gt; abs(3 + 4j) # Модуль комплексного числа 5.0 \u0026gt;\u0026gt;\u0026gt; pow(3 + 4j, 2) # Возведение в степень (-7+24j) Для работы с комплексными числами используется также модуль cmath.\nЗавершение Статья может быть моментами неточной. Я буду рад почитать ваши комментари :)\n","date":"2022-07-22T01:00:00Z","image":"https://kotazzz.github.io/p/py02/00_placeholder_hu277611839423b3830d80bc9be9a9459c_33437_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py02/","title":"Py02. Основы Python"},{"content":"Установка на Windows Я не буду долго зацикливаться на этом этапе. Скачать установщик можно на python.org. Если качать Python с других сайтов, можно подцепить вирус или троян. Скачивайте программы только с официальных сайтов. После загрузки отметьте Add to path и проследуйте инструкциям. В windows 10 может появиться предупреждение с кнопкой щита (Disable Length Limit), стоит нажать на нее.\nУстановка на Linux Для каждого дистрибутива есть свой пакетный менеджер, попробуйте найти информацию в интернете\napt install python - ubuntu и другие системы, использующие apt pkg/apt install python - Термукс (если вы собираетесь использовать телефон) pacman -S python - arch linux и другие системы, использующие pacman yum install python - centos и другие системы, использующие yum dnf install python - fedora и другие системы, использующие dnf zypper install python - opensuse и другие системы, использующие zypper В случае ошибок прав используйте sudo в начале команды, что бы запустить процесс установки от имени администратора. В большинстве случаев вас попросят подтвердить операцию - введите Y и нажмите Enter.\nПроверка и интерактивный режим В постах, где используется \u0026raquo;\u0026gt; и \u0026hellip; - используется интерактивный режим. Язык питон интерпретируемый (так же как и javascript, например) - то есть каждое действие в языке сначала читается, потом сразу выполняется. В других (компилируемых) языках (c++, java, etc\u0026hellip;) сначала создается готовый файл, а потом его можно сразу запустить без дополнительных инструментов\nКомпилятор (англ. compiler - составитель, собиратель) читает всю программу целиком, делает ее перевод и создает законченный вариант программы на машинном языке, который затем и выполняется. Результат работы компилятора — бинарный исполняемый файл. Интерпретатор (англ. interpreter - истолкователь, устный переводчик) переводит и выполняет программу строка за строкой.\nКогда установка закончится, нужно проверить, что всё было сделано правильно. Для этого в командной строке наберите py (латиницей) или python и нажмите клавишу ввода. Если всё хорошо, в ответ Python вам напишет номер своей версии и сборки и предложит несколько команд для знакомства с собой: Пожалуй, самый простой способ запускать программы на языке Python - это вводить инструкции непосредственно в командной строке интерпретатора, которая иногда называется интерактивной оболочкой. Например, выведем на экран \u0026ldquo;hello world\u0026rdquo; и рассмотрим парочку примеров:\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; print(\u0026#34;Hello, world!\u0026#34;) Hello, world! \u0026gt;\u0026gt;\u0026gt; # Это комментарий, пайтон ничего не делает \u0026gt;\u0026gt;\u0026gt; # Или Попробуем вывести на экран число пять: \u0026gt;\u0026gt;\u0026gt; 5 5 \u0026gt;\u0026gt;\u0026gt; # Посчитаем 2+2*2: \u0026gt;\u0026gt;\u0026gt; 2+2*2 6 Заходя в пперед, есть более сложные операторы, которые требуют ввода на несколько строк, в таком случае, приглашение меняется с \u0026gt;\u0026gt;\u0026gt; на .... Этот режим продолжается до тех пор, пока вы не нажмете Enter, оставив пустую строку:\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; if 2+2*2 == 6: ... print(\u0026#34;Верно!\u0026#34;) ... else: ... print(\u0026#34;Неверно!\u0026#34;) ... Верно! Запуск файлов Алгоритм действий прост:\nСоздаем файл любым способом. Файл должен оканчиваться на .py. Например, hello.py. Запускаем терминал/консоль (или запускаем прямо в папке с файлом) Windows: Windows + R - Вводим cmd - Enter Linux Ctrl + Shift + T Передвигаемся к файлу Вариант 1: cd ПОЛНЫЙ_ПУТЬ_К_ФАЙЛУ cd C:\\Users\\Вася\\Desktop\\hello.py - Windows cd /home/user/hello.py - Linux Вариант 2: Постепенно предвижение cd ВЛОЖЕННАЯ_ПАПКА - перейти в папку cd .. - для передвижения на уровень вверх Linux ls / Windows dir - для просмотра содержимого папки Вводим команду для запуска файла Вариант 1: python hello.py - универсальный метод для запуска любого файла на Python Вариант 2: python3 hello.py - указываем, что используем имеено Python 3.x.x Вариант 3: py -3 hello.py - лучший метод для Windows Мои примеры будут приближены к Linux, поэтому мои действия:\n1 2 3 4 5 6 ~$ touch hello.py # Создаем файл ~$ nano hello.py # Открываем файл в редакторе nano, редактируем и сохраняем ~$ cat hello.py # Выводим содержимое файла print(\u0026#34;Hello, world!\u0026#34;) ~$ python hello.py # Запускаем файл Hello, world! Завершение Статья может быть моментами неточной. Я буду рад почитать ваши комментари :)\n","date":"2022-07-22T00:00:00Z","image":"https://kotazzz.github.io/p/py01/00_placeholder_hu2c7e018ed9f753eaee0b80b8a0ca4196_10087_120x120_fill_q75_box_smart1.jpg","permalink":"https://kotazzz.github.io/p/py01/","title":"Py01. Введение в Python"},{"content":"Тут будут публиковаться различные гайды и курсы по различным темам\n","date":"2022-07-22T00:00:00Z","permalink":"https://kotazzz.github.io/p/first/","title":"Первый пост"}]