---
author: Kotaz
title: Циклы Python
date: 2022-07-23 04:00:00
description: Циклы for и while, операторы break и continue, волшебное слово else
categories: ["courses"]
tags: ["Python"]
slug: py05
# image: 00_placeholder.jpg
---

# Циклы for и while, операторы break и continue, волшебное слово else

Я расскажу о циклах for и while, операторах break и continue, а также о слове else, которое, будучи употребленное с циклом, может сделать программный код несколько более понятным.

## Цикл while

While - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.

```py
>>> i = 5
>>> while i < 15:
...     print(i)
...     i = i + 2
...
5
7
9
11
13
```

## Цикл for

### Общее понятие

Цикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (например строке или списку), и во время каждого прохода выполняет тело цикла.
Цикл for используется в том случае, когда необходимо выполнить некоторую часть кода до тех пор, пока не будет выполнено заданное условие. Цикл for также называют циклом c предусловием. Лучше использовать цикл for, если количество итераций известно заранее.

```py
>>>
>>> for i in 'hello world':
...     print(i * 2, end='')
...
hheelllloo  wwoorrlldd
```

### `range()`

Мы используем встроенную функцию Python range. Функция range создаст список длинной в «n» элементов. В Python версии 2.Х существует другая функция под названием xrange, которая является генератором чисел и не такая ресурсоемкая, как range. Ранее разработчики сменили xrange на range в Python 3. Вот пример:

```py
print(range(5)) # ответ: range(0, 5)
```

Как вы видите, функция range взяла целое число и вернула объект range. Функция range также принимает начальное значение, конечное значение и значение шага. Вот еще два примера:

```py
a = range(5, 10)
print(a) # range(5, 10)

b = list(range(1, 10, 2))
print(b) # [1, 3, 5, 7, 9]
```

В пером примере показано, что вы можете передать начальное и конечное значение, и функция range вернет числа, начиная с начального значения вплоть до (но не включая) последнее значение. Например, при запросе 5-10 мы получим 5-9. Во втором примере видно, как использовать функцию списка (list) для того, чтобы функция range вернула каждый второй элемент, между 1 и 10. Так что она начинает с 1, пропускает 2 и так далее. Теперь вы, наверное, гадаете, что же именно она будет делать с циклами? Что-ж, есть один простой способ показать, как работает цикл с использованием функции range! Давайте взглянем:

```py
for number in range(5):
    print(number)
```

Что здесь произошло? Давайте почитаем слева на право, чтобы понять это. Для каждого числа в диапазоне 5 мы вводим число. Мы знаем, что если мы вызываем range со значением 5, мы получим список из 5 элементов. Так что каждый раз, проходя через цикл, она выводит каждый из элементов. Цикл for, показанный выше, может быть эквивалентом следующего:

```py
for number in [0, 1, 2, 3, 4]:
    print(number)
```

Мы попробуем применить цикл в функции range, но нам нужно вывести только целые числа. Чтобы сделать это, нам нужно использовать условный оператор вместо параметра шага range. Это можно сделать следующим образом:

```py
for number in range(10):
    if number % 2 == 0:
        print(number)
# 0
# 2
# 4
# 6
# 8
```

Вы наверное гадаете, что вообще здесь происходит? Что еще за знак процента? В Python, % называется оператором модуля. Когда вы используете оператор модуля, он возвращает остаток. Когда вы делите целое число на два, вы получаете число без остатка, так что мы выводим эти числа. Вам, возможно, не захочется использовать оператор модуля часто в будущем, но в моей работе он нередко помогает. Теперь мы можем взглянуть на цикл while.

### Словари

Функция range лишь делает результат несколько меньшим. Цикл for может обходить любой итератор Python. Мы уже видели, как именно он может работать со списком. Давайте взглянем, может ли он выполнять итерацию со словарем.

```py
a_dict = {"one":1, "two":2, "three":3}

for key in a_dict:
    print(key)
```

Когда вы используете for в словаре, вы увидите, что он автоматически перебирает ключи. Вам не нужно указывать ключ for в a_dict.keys() (впрочем, это также работает). Python делает только нужные нам вещи. Вы возможно думаете, почему ключи выводятся в другом порядке, отличном от того, какой был указан в словаре? Как мы знаем из соответствующей статьи, словари не упорядочены, так что мы можем выполнять итерацию над ними, при этом ключи могут быть в любом порядке. Теперь, зная, что ключи могут быть отсортированы, вы можете отсортировать их до итерации. Давайте немного изменим словарь, чтобы увидеть, как это работает.

```py
a_dict = {1:"one", 2:"two", 3:"three"}
keys = a_dict.keys()

keys = sorted(keys)
for key in keys:
    print(key)
# 1
# 2
# 3
```

Давайте остановимся и разберемся с тем, что делает этот код. Во-первых, мы создали словарь, в котором ключи выступают в качестве целых чисел, вместо строк. Далее, мы извлекли ключи из словаря. Каждый раз, когда вы взываете метод keys(), он возвращает неупорядоченный список ключей. Если вы выведите их, и увидите, что они расположен в порядке по возрастанию, то это просто случайность. Теперь у нас есть доступ к ключам словаря, которые хранятся в переменной, под названием keys. Мы сортируем наш список, после чего используем цикл for в нем. Теперь мы готовы к тому, чтобы сделать все немного интереснее.

## Оператор continue

Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)

```py
>>>
>>> for i in 'hello world':
...     if i == 'o':
...         continue
...     print(i * 2, end='')
...
hheellll  wwrrlldd
```

## Оператор break

Оператор break досрочно прерывает цикл.

```py
>>>
>>> for i in 'hello world':
...     if i == 'o':
...         break
...     print(i * 2, end='')
...
hheellll
```

## Волшебное слово else

Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.

```py
>>>
>>> for i in 'hello world':
...     if i == 'a':
...         break
... else:
...     print('Буквы a в строке нет')
...
Буквы a в строке нет
```
